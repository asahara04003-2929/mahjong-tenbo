<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<link rel="manifest" href="/manifest.json">
<link rel="stylesheet" href="style.css">

<meta name="theme-color" content="#CFEEC0">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

<script src="firebaseConfig.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<style>
.hidden { display:none; }
.room { border:1px solid #ccc; margin:6px 0; padding:6px; }
select { margin-left:6px; }
</style>
</head>

<body>

<!-- ========================================= -->
<!-- ログイン -->
<!-- ========================================= -->
<div id="loginScreen">
  <input id="loginPass" placeholder="パスワード">
  <button onclick="login()">ログイン</button>
</div>

<!-- ========================================= -->
<!-- ルーム一覧 -->
<!-- ========================================= -->
<div id="roomListScreen" class="hidden">
  <h2>ルーム一覧</h2>
  <label for="integer">原点:</label>
  <input type="number" id="startPoint" name="startPoint" step="5000" value=45000 placeholder="45000">
  <label for="integer">返し点:</label>
  <input type="number" id="returnPoint" name="returnPoint" step="5000" value=50000 placeholder="50000">
  <label><input type="radio" name="rule" value="3" checked>3麻</label>
  <label><input type="radio" name="rule" value="3r4">3麻4人回し</label>
  <label><input type="radio" name="rule" value="4">4麻</label>
  <button id="createRoomBtn" onclick="createRoom()">ルーム作成</button>
  <div id="roomList"></div>
</div>

<!-- ========================================= -->
<!-- 参加者設定 -->
<!-- ========================================= -->
<div id="playerSetupScreen" class="hidden">
  <h2>参加者設定</h2>
  <div id="seatArea"></div>
  <button onclick="openAddPlayer()">プレイヤー追加</button>
  <button onclick="backToRoomList()">戻る</button>
  <button id="startBtn" disabled onclick="renderPlayerSelect()">対局開始</button>
</div>

<!-- ========================================= -->
<!-- プレイヤー追加 -->
<!-- ========================================= -->
<div id="addPlayerScreen" class="hidden">
  <h2>プレイヤー追加</h2>
  <input id="newPlayerName" placeholder="名前">
  <button onclick="addPlayer()">登録</button>
  <button onclick="backToPlayerSetup()">戻る</button>
</div>

<!-- ========================================= -->
<!-- プレイヤー選択画面 -->
<!-- ========================================= -->
<div id="playerSelectScreen" class="hidden">
  <h2>自席を選択してください。</h2>

  <div id="playerSelectTable" style="display: grid; grid-template-columns: 1fr 1fr 1fr; text-align: center; row-gap: 10px; column-gap: 10px; justify-items: center;">
    <!-- 東 -->
    <div></div>
    <div id="player-east"></div>
    <div></div>

    <!-- 南/北 -->
    <div id="player-south"></div>
    <div></div>
    <div id="player-north"></div>

    <!-- 西 -->
    <div></div>
    <div id="player-west"></div>
    <div></div>
  </div>

  <br>
  <button onclick="backToRoomList()">一覧画面へ戻る</button>
</div>

<!-- ========================================= -->
<!-- 集計中画面 -->
<!-- ========================================= -->
<div id="calculatingScreen" class="hidden">
  <h2>集計</h2>

  <!-- 006（上） -->
  <div id="calcTopName" style="text-align:center; margin-bottom:10px;">-</div>

  <!-- 002（上のボタン） -->
  <div style="text-align:center; margin-bottom:6px;">
    <button id="btnYakitoriTop" onclick="toggleYakitoriByPos('N')">-</button> <!-- 002 -->
  </div>

  <!-- 010（上のスコア表示） -->
  <div id="calcTopScore" style="text-align:center; margin-bottom:18px;">-</div>

  <!-- 左右（001/003 ボタン、005/007 名前、009/011 スコア） -->
  <div style="display:flex; justify-content:space-between; align-items:center; margin:16px 0;">
    <div style="width:40%; text-align:left;">
      <div id="calcLeftName">-</div> <!-- 005 -->
      <button id="btnYakitoriLeft" onclick="toggleYakitoriByPos('W')">-</button> <!-- 001 -->
      <div id="calcLeftScore">-</div> <!-- 009 -->
    </div>

    <div style="width:40%; text-align:right;">
      <div id="calcRightName">-</div> <!-- 007 -->
      <button id="btnYakitoriRight" onclick="toggleYakitoriByPos('S')">-</button> <!-- 003 -->
      <div id="calcRightScore">-</div> <!-- 011 -->
    </div>
  </div>

  <!-- 自分（008 名前 / 004 ヤキトリボタン / 012 スコア） -->
  <div style="text-align:center; margin-top:20px;">
    <div id="calcMyName">-</div> <!-- 008 -->
    <button id="btnYakitoriMe" onclick="toggleYakitoriByPos('ME')">-</button> <!-- 004 -->
    <div id="calcMyScore" style="margin-top:6px;">-</div> <!-- 012 -->
  </div>

  <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
    <button id="btnCalcEnd" onclick="finishCalculating()">集計完了</button> <!-- 013 -->
    <button onclick="backToRoomList()">ルーム一覧へ戻る</button> <!-- 014 -->
  </div>
</div>

<!-- ========================================= -->
<!-- 対局終了画面 -->
<!-- ========================================= -->
<div id="endScreen" class="hidden">
  <h2>対局終了</h2>

  <div style="margin-bottom:12px;">
    ルール：<button id="endRuleBtn" disabled>-</button> <!-- 001 -->
    <div>原点：<span id="endStartPoint">-</span></div>  <!-- 002 -->
    <div>返し点：<span id="endReturnPoint">-</span></div> <!-- 003 -->
  </div>

  <!-- 順位表示 -->
  <div id="endRankGrid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:12px; text-align:center;">
    <!-- 1位 -->
    <div>
      <div>1位</div>
      <div id="rank1Name">-</div>  <!-- 004 -->
      <div id="rank1Score">-</div> <!-- 008 -->
      <div id="rank1Yakitori"></div> <!-- 012 -->
    </div>

    <!-- 2位 -->
    <div>
      <div>2位</div>
      <div id="rank2Name">-</div>  <!-- 005 -->
      <div id="rank2Score">-</div> <!-- 009 -->
      <div id="rank2Yakitori"></div> <!-- 013 -->
    </div>

    <!-- 3位 -->
    <div>
      <div>3位</div>
      <div id="rank3Name">-</div>  <!-- 006 -->
      <div id="rank3Score">-</div> <!-- 010 -->
      <div id="rank3Yakitori"></div> <!-- 014 -->
    </div>

    <!-- 4位 -->
    <div id="rank4Box">
      <div>4位</div>
      <div id="rank4Name">-</div>  <!-- 007 -->
      <div id="rank4Score">-</div> <!-- 011 -->
      <div id="rank4Yakitori"></div> <!-- 015 -->
    </div>
  </div>

  <div style="margin-top:18px; text-align:center;">
    <button onclick="backToRoomList()">ルーム一覧へ戻る</button> <!-- 016 -->
  </div>
</div>



<!-- ========================================= -->
<!-- 対局画面 -->
<!-- ========================================= -->
<div id="gameScreen" class="hidden">
  <h2 class="gs-title">対局中</h2>

  <div class="gs-layout">
    <!-- =========================
         左：卓（点数表示）
    ========================== -->
    <section class="gs-tableWrap">
      <div class="gs-riichiLine">
        <div class="gs-riichiText">リーチ棒：<span id="riichiCount">0</span></div>
      </div>

      <div id="gameTable" class="gs-table">
        <!-- 北(相手) -->
        <div class="gs-seat gs-north">
          <div class="gs-name" id="nameN">-</div>
          <div class="gs-point" id="pointN">-</div>
          <div class="gs-diff" id="diffN">-</div>
          <button class="gs-sendBtn" id="btnSendN" onclick="selectRecipient('N')">送る</button>
        </div>

        <!-- 西(相手) -->
        <div class="gs-seat gs-west">
          <div class="gs-name" id="nameW">-</div>
          <div class="gs-point" id="pointW">-</div>
          <div class="gs-diff" id="diffW">-</div>
          <button class="gs-sendBtn" id="btnSendW" onclick="selectRecipient('W')">送る</button>
        </div>

        <!-- 東(自分) -->
        <div class="gs-seat gs-self">
          <div class="gs-selfName" id="myName">-</div>
          <div class="gs-selfPoint" id="myPoint">-</div>
        </div>

        <!-- 南(相手) -->
        <div class="gs-seat gs-south">
          <div class="gs-name" id="nameS">-</div>
          <div class="gs-point" id="pointS">-</div>
          <div class="gs-diff" id="diffS">-</div>
          <button class="gs-sendBtn" id="btnSendS" onclick="selectRecipient('S')">送る</button>
        </div>
      </div>
    </section>

    <!-- =========================
         右：操作パネル
    ========================== -->
    <aside class="gs-panel">
      <!-- リーチ系 -->
      <div class="gs-row">
        <button class="gs-btn gs-btnWide" id="btnRiichiAdd" onclick="onRiichiAdd()">リーチ</button>
        <button class="gs-btn" id="btnRiichiTake" onclick="onRiichiTake()">受取</button>
      </div>

      <!-- 送金状況 -->
      <div class="gs-card">
        <div class="gs-cardRow">
          <div class="gs-cardLabel">送り先：</div>
          <div class="gs-cardValue"><span id="sendToName">-</span></div>
        </div>
        <div class="gs-cardRow">
          <div class="gs-cardLabel">送る点数：</div>
          <div class="gs-cardValue"><span id="sendAmount">0</span></div>
        </div>
      </div>

      <!-- 加算ボタン -->
      <div class="gs-amountGrid">
        <button class="gs-btn" onclick="addAmount(10000)">10000</button>
        <button class="gs-btn" onclick="addAmount(1000)">1000</button>
        <button class="gs-btn" onclick="addAmount(100)">100</button>
        <button class="gs-btn" onclick="addAmount(5000)">5000</button>
        <button class="gs-btn" onclick="addAmount(500)">500</button>
        <button class="gs-btn gs-btnSub" onclick="cancelTransfer()">クリア</button>
      </div>

      <!-- 確定/取消 -->
      <div class="gs-row">
        <button class="gs-btn gs-btnPrimary" id="btnConfirm" onclick="confirmTransfer()">確定</button>
        <button class="gs-btn" id="btnCancel" onclick="cancelTransfer()">取消</button>
      </div>

      <!-- 対局終了 -->
      <div class="gs-row">
        <button class="gs-btn gs-btnDanger" id="btnEndGame" onclick="endGame()">対局終了</button>
        <button class="gs-btn" onclick="backToRoomList()">ルーム一覧へ戻る</button>
      </div>
    </aside>
  </div>
</div>



<script>
// ============================================
//                  スクリプト
// ================= Firebase =================
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
firebase.initializeApp(window.firebaseConfig);
const db = firebase.database();

// ===== DOM参照を明示（idの自動グローバルに依存しない）=====
const loginScreen      = document.getElementById("loginScreen");
const roomListScreen   = document.getElementById("roomListScreen");
const playerSetupScreen= document.getElementById("playerSetupScreen");
const addPlayerScreen  = document.getElementById("addPlayerScreen");
const playerSelectScreen = document.getElementById("playerSelectScreen");
const gameScreen       = document.getElementById("gameScreen");
const calculatingScreen= document.getElementById("calculatingScreen");
const endScreen        = document.getElementById("endScreen");

const loginPass        = document.getElementById("loginPass");
const roomList         = document.getElementById("roomList");

const startBtn         = document.getElementById("startBtn");
const seatArea         = document.getElementById("seatArea");
const newPlayerName    = document.getElementById("newPlayerName");


const APP_STATE_KEY = "mahjong_app_state";

// ================= 状態 =================
let currentRoomId = null;
let currentRule = null;
let currentGameInfo = {
  playerId: null,
  direction: null,
  status: null
}



// プルダウン用
let entryPlayers = {};
let seats = { 東:"", 南:"", 西:"", 北:"" };

const RULES = {"3":"３麻", "3r4":"３麻４人回", "4":"4麻"};
const GAME_STATUS = {"waiting": "待機中","playing": "対局中", "calculating": "集計中", "end":"対局終了"}

// ================= ログイン =================
function login() {
  db.ref("systemConfig/loginPass").once("value").then(s => {
    if (s.val() === loginPass.value) {
      loginScreen.classList.add("hidden");
      roomListScreen.classList.remove("hidden");
      saveAppState("roomList");
      subscribeRooms();
    }
  });
}

// ================= ルーム一覧 =================
function loadRooms() {
  roomList.innerHTML = "";

  // ヘッダー
  const header = document.createElement("div");
  header.style.fontWeight = "bold";
  header.style.display = "flex";
  header.style.gap = "10px";
  header.innerHTML = `
    <div style="width:150px;">ルームID</div>
    <div style="width:100px;">ルール</div>
    <div style="width:100px;">状態</div>
    <div style="width:100px;">待機人数</div>
    <div style="flex:1;">操作</div>
  `;
  roomList.appendChild(header);

  // db.ref("rooms").once("value").then(snap => {
  //   const rooms = snap.val() || {};
  //   console.log("rooms:", rooms);

  //   for (let id in rooms) {
  //     const r = rooms[id];
  //     const status = r.gameConfig?.status ?? "-";
  //     if (!["waiting","playing","end","calculating"].includes(status)) continue;

  //     const div = document.createElement("div");
  //     div.style.display = "flex";
  //     div.style.gap = "10px";
  //     div.style.borderBottom = "1px solid #ccc";
  //     div.style.padding = "4px 0";

  //     const playerCount = r.players ? Object.keys(r.players).length : 0;

  //     div.innerHTML = `
  //       <div style="width:150px;">${id}</div>
  //       <div style="width:100px;">${RULES[r.gameConfig.rule] || r.gameConfig.rule}</div>
  //       <div style="width:100px;">${GAME_STATUS[r.gameConfig.status] || r.gameConfig.status}</div>
  //       <div style="width:100px;">${playerCount}</div>
  //       <div style="flex:1;">
  //         ${r.gameConfig.status==="waiting" || r.gameConfig.status==="playing" ? `<button onclick="enterRoom('${id}')">入室</button>` : ""}
  //         ${r.gameConfig.status==="calculating" ? `<button onclick="enterRoom('${id}')">集計</button>` : ""}
  //         ${r.gameConfig.status==="end" ? `<button onclick="openEndScreen()">結果</button>` : ""}
  //         ${r.gameConfig.status==="waiting" ? `<button onclick="deleteRoom('${id}')">削除</button>` : ""}
  //       </div>
  //     `;
  //     roomList.appendChild(div);
  //   }
  // });
}


// ===== ルーム一覧リアルタイム購読 =====
let roomsUnsub = null;

function subscribeRooms() {
  const ref = db.ref("rooms");

  if (roomsUnsub) roomsUnsub();

  const handler = (snap) => {
    try {
      const rooms = snap.val() || {};
      renderRoomList(rooms);
      if (roomList.children.length === 1) { // headerしかない
        const div = document.createElement("div");
        div.style.padding = "8px 0";
        div.textContent = "ルームがありません（または表示対象ステータスがありません）";
        roomList.appendChild(div);
      }
    } catch (e) {
      console.error("renderRoomList error:", e);
      alert("ルーム一覧描画でエラー。コンソールを確認してください。");
    }
  };

  const onError = (err) => {
    console.error("rooms subscribe error:", err);
    alert("rooms の読み取りに失敗しました。DB権限やパスを確認してください。");
  };

  ref.on("value", handler, onError);
  roomsUnsub = () => ref.off("value", handler);

  ref.once("value").then(handler).catch(onError);
}

function renderRoomList(rooms) {
  roomList.innerHTML = "";

  // ヘッダー
  const header = document.createElement("div");
  header.style.fontWeight = "bold";
  header.style.display = "flex";
  header.style.gap = "10px";
  header.innerHTML = `
    <div style="width:150px;">ルームID</div>
    <div style="width:100px;">ルール</div>
    <div style="width:100px;">状態</div>
    <div style="width:100px;">待機人数</div>
    <div style="flex:1;">操作</div>
  `;
  roomList.appendChild(header);

  const statusAllow = ["waiting","playing","calculating","end"];

  for (const id in rooms) {
    const r = rooms[id] || {};
    const status = r.gameConfig?.status ?? "-";
    if (!statusAllow.includes(status)) continue;

    const div = document.createElement("div");
    div.style.display = "flex";
    div.style.gap = "10px";
    div.style.borderBottom = "1px solid #ccc";
    div.style.padding = "4px 0";

    const playerCount = r.players ? Object.keys(r.players).length : 0;

    const ruleText = RULES[r.gameConfig?.rule] || r.gameConfig?.rule || "-";
    const stText   = GAME_STATUS[status] || status;

    div.innerHTML = `
      <div style="width:150px;">${id}</div>
      <div style="width:100px;">${ruleText}</div>
      <div style="width:100px;">${stText}</div>
      <div style="width:100px;">${playerCount}</div>
      <div style="flex:1;">
        ${["waiting","playing","calculating"].includes(status) ? `<button onclick="enterRoom('${id}')">入室</button>` : ""}
        ${status === "end" ? `<button onclick="enterRoom('${id}'); openEndScreen();">結果</button>` : ""}
        ${status === "waiting" ? `<button onclick="deleteRoom('${id}')">削除</button>` : ""}
      </div>
    `;
    roomList.appendChild(div);
  }

  // 0件のときの表示
  if (roomList.children.length === 1) {
    const div = document.createElement("div");
    div.style.padding = "8px 0";
    div.textContent = "ルームがありません（または表示対象ステータスがありません）";
    roomList.appendChild(div);
  }
}




const startPointInput = document.getElementById("startPoint");
const returnPointInput = document.getElementById("returnPoint");
const createRoomBtn = document.getElementById("createRoomBtn");

// ルーム作成ボタン活性/非活性制御　原点<=返し点のときは活性
function validateRoomButton() {
  const start = parseInt(startPointInput.value, 10) || 0;
  const ret   = parseInt(returnPointInput.value, 10) || 0;

  if (start <= ret) {
    createRoomBtn.disabled = false;
  } else {
    createRoomBtn.disabled = true;
  }
}

// イベント登録
startPointInput.addEventListener("input", validateRoomButton);
returnPointInput.addEventListener("input", validateRoomButton);

// 初期チェック(ルーム作成ボタン活性/非活性制御)
validateRoomButton();




function createRoom() {
  const rule = document.querySelector("input[name=rule]:checked")?.value;
  const startPoint  = parseInt(document.querySelector("input[name=startPoint]")?.value)  || 45000;
  const returnPoint = parseInt(document.querySelector("input[name=returnPoint]")?.value) || 50000;
  if (!rule) return;

  const d = new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const id = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  db.ref("rooms/"+id).set({
    gameConfig:{
      startPoint,
      returnPoint,
      rule,
      status:"waiting",
      riichiStickCount: 0
    },
    players:{},
    transferRequests:{},
    gameLogs:{}
  }).then(() => {
    // subscribeRooms の on("value") が勝手に更新するので不要
  });
}




// 参加者設定処理
function enterRoom(id) {
  saveAppState("playerSetupScreen");
  currentRoomId = id;

  // ルール取得
  db.ref(`rooms/${id}/gameConfig/rule`).once("value").then(s => {
    currentRule = s.val();

    // seats の初期化はここで1回だけ
    seats = { 東:"", 南:"", 西:"", 北:"" };

    // 画面切り替え
    roomListScreen.classList.add("hidden");
    playerSetupScreen.classList.remove("hidden");

    // プレイヤー選択用データをロード
    loadEntryPlayers();

    // リアルタイム監視
    db.ref(`rooms/${currentRoomId}/players`).on("value", snap => {
      const players = snap.val() || {};

      // DB に存在する方向だけを seats に反映（未選択は空のまま）
      Object.keys(seats).forEach(dir => seats[dir] = ""); // 一度全席リセット
      for (const [pid, p] of Object.entries(players)) {
        if (p.direction) seats[p.direction] = pid;
      }

      renderSeats();
      checkStart();
    });
  });
}

// =======================
// 参加者のプルダウン＆ラジオボタン描画
// =======================
async function renderSeats() {
  // roomInfoDiv 作成（1回だけ）
  let infoDiv = document.getElementById("roomInfoDiv");
  if (!infoDiv) {
    infoDiv = document.createElement("div");
    infoDiv.id = "roomInfoDiv";
    infoDiv.style.marginBottom = "8px";
    seatArea.appendChild(infoDiv);
  }

  // ルームの gameConfig と players をまとめて取得
  const [configSnap, playersSnap] = await Promise.all([
    db.ref(`rooms/${currentRoomId}/gameConfig`).once("value"),
    db.ref(`rooms/${currentRoomId}/players`).once("value")
  ]);

  const gameConfig = configSnap.val() || {};
  const playersData = playersSnap.val() || {};

  // ルーム情報更新
  infoDiv.innerHTML = `
    <div>ルール：${RULES[gameConfig.rule] || gameConfig.rule}</div>
    <div>原点：${gameConfig.startPoint ?? "-"}</div>
    <div>返し点：${gameConfig.returnPoint ?? "-"}</div>
  `;

  // seatArea から既存プルダウン削除
  const existingDivs = Array.from(seatArea.children).filter(d => d.id !== "roomInfoDiv");
  existingDivs.forEach(d => seatArea.removeChild(d));

  const usedPlayerIds = new Set(Object.values(seats).filter(pid => pid));

  for (const dir of Object.keys(seats)) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.marginBottom = "4px";

    const label = document.createElement("label");
    label.textContent = dir;
    label.style.marginRight = "8px";
    container.appendChild(label);

    const select = document.createElement("select");

    const defaultOpt = document.createElement("option");
    defaultOpt.value = "";
    defaultOpt.textContent = "未選択";
    select.appendChild(defaultOpt);

    const selectedCount = Object.values(seats).filter(v => v).length;
    const needCount = (currentRule === "3") ? 3 : 4;

    // この席が未選択で、すでに必要人数が揃っているなら disabled
    if (!seats[dir] && selectedCount >= needCount) {
      select.disabled = true;
    }

    for (const [id, p] of Object.entries(entryPlayers)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name;

      // 他の席にいるプレイヤーは選択不可
      if (usedPlayerIds.has(id) && seats[dir] !== id) {
        opt.disabled = true;
        opt.style.color = "#999";
      }

      // すでにその席にいる場合は選択状態
      if (seats[dir] === id) opt.selected = true;

      select.appendChild(opt);
    }

    select.onchange = async e => {
      const newPlayerId = e.target.value;
      const oldPlayerId = seats[dir];

      // 前のプレイヤーを削除
      if (oldPlayerId && oldPlayerId !== newPlayerId) {
        await db.ref(`rooms/${currentRoomId}/players/${oldPlayerId}`).remove();
      }

      seats[dir] = newPlayerId;

      if (newPlayerId) {
        const startPointSnap = await db.ref(`rooms/${currentRoomId}/gameConfig/startPoint`).once("value");
        const startPoint = startPointSnap.val();

        await db.ref(`rooms/${currentRoomId}/players/${newPlayerId}`).set({
          direction: dir,
          status: "waiting",
          point: startPoint,
          score: null,
          yakitoriFlg: true
        });

        currentGameInfo.playerId = newPlayerId;
        currentGameInfo.direction = dir;
        currentGameInfo.status = "waiting";
      } else {
        currentGameInfo.playerId = null;
        currentGameInfo.direction = null;
        currentGameInfo.status = null;
      }

      checkStart();
      saveAppState("playerSetupScreen");
    };

    container.appendChild(select);
    seatArea.appendChild(container);
  }
}


function loadEntryPlayers() {
  db.ref("systemConfig/entryPlayers").once("value").then(snap => {
    entryPlayers = snap.val() || {};
    renderSeats();
  });
}

let selectedSeat = "";

// 対局開始ボタン制御
function checkStart() {
  const count = Object.values(seats).filter(v=>v).length;
  const need = currentRule==="3" ? 3 : 4;
  startBtn.disabled = count !== need;
}


// ================= プレイヤー追加 =================
function openAddPlayer() {
  playerSetupScreen.classList.add("hidden");
  addPlayerScreen.classList.remove("hidden");
  saveAppState("addPlayerScreen");
}

function addPlayer() {
  const name = newPlayerName.value.trim();
  if (!name) return;

  const id = "p" + Date.now();
  db.ref(`systemConfig/entryPlayers/${id}`).set({ name }).then(() => {
    newPlayerName.value = "";
    backToPlayerSetup();
  });
}


// ===============================
// プレイヤー選択用ボタン描画
// ===============================
async function renderPlayerSelect() {
  if (!currentRoomId) return;
  playerSetupScreen.classList.add("hidden");
  playerSelectScreen.classList.remove("hidden");
  saveAppState("playerSelectScreen");

  const [playersSnap, entrySnap] = await Promise.all([
    db.ref(`rooms/${currentRoomId}/players`).once("value"),
    db.ref(`systemConfig/entryPlayers`).once("value")
  ]);

  const players = playersSnap.val() || {};
  const entryPlayers = entrySnap.val() || {};
  const directions = { 北:"player-north", 東:"player-east", 南:"player-south", 西:"player-west" };

  // direction -> playerId を1回で作る
  const dirToPid = {};
  for (const [pid, p] of Object.entries(players)) {
    if (p?.direction) dirToPid[p.direction] = pid;
  }

  for (const [dir, divId] of Object.entries(directions)) {
    const container = document.getElementById(divId);
    if (!container) continue;

    container.innerHTML = "";

    const playerId = dirToPid[dir];
    if (!playerId) {
      container.textContent = "未割当";
      continue;
    }

    const name = entryPlayers[playerId]?.name ?? "不明";

    const btn = document.createElement("button");
    btn.textContent = name;

    btn.onclick = () => selectPlayer(playerId, dir);
    container.appendChild(btn);
  }
}


// ===============================
// ボタン選択時の処理
// ===============================
async function selectPlayer(playerId, direction) {
  currentGameInfo.playerId = playerId;
  currentGameInfo.direction = direction;
  currentGameInfo.status = "playing";

  // 自分を playing に
  await db.ref(`rooms/${currentRoomId}/players/${playerId}/status`).set("playing");

  // ★ルーム状態を waiting → playing に（多重更新防止）
  const roomStatusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  await roomStatusRef.transaction(cur => {
    if (cur === "waiting") return "playing";
    return; // それ以外は変更なし
  });

  openGameScreen();
}



// ===============================
// 対局中 画面用（一時状態）
// ===============================
let gameStateUnsub = null;

let selectedRecipient = null; // 'N'|'W'|'S'
let sendAmountValue = 0;

// 方向の回転：自分がどのdirectionでも、画面上の N/W/S に相対配置する
// 例：自分が東なら N=北 W=西 S=南（画像仕様の例と一致）
const DIRS = ["東","南","西","北"];
function toRelative(selfDir, otherDir) {
  const si = DIRS.indexOf(selfDir);
  const oi = DIRS.indexOf(otherDir);
  if (si < 0 || oi < 0) return null;

  const diff = (oi - si + 4) % 4;

  // 自分を下固定：上=対面、右=次席、左=前席
  if (diff === 1) return "S"; // 右
  if (diff === 2) return "N"; // 上(対面)
  if (diff === 3) return "W"; // 左
  return null; // diff===0 は自分
}

function setText(id, text){ const el=document.getElementById(id); if(el) el.textContent = text; }

function setDiff(elId, diff){
  const el = document.getElementById(elId);
  if (!el) return;
  const v = Number(diff) || 0;
  el.textContent = (v >= 0 ? `+${v}` : `${v}`);
  el.classList.toggle("negative", v < 0);
}

// ===============================
// 対局画面を開く（呼び出し元は selectPlayer() など）
// ===============================
function openGameScreen() {
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  playerSetupScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  playerSelectScreen?.classList.add("hidden"); // ←戻す
  gameScreen.classList.remove("hidden");

  selectedRecipient = null;
  sendAmountValue = 0;
  setText("sendToName", "-");
  setText("sendAmount", "0");

  if (gameStateUnsub) gameStateUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);
    renderGameUI(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  gameStateUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
  subscribeRoomStatus();
}

let statusUnsub = null;

function subscribeRoomStatus() {
  if (!currentRoomId) return;

  const ref = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  if (statusUnsub) statusUnsub();

  const handler = (snap) => {
    const st = snap.val();
    if (st === "calculating") {
      openCalculatingScreen();
    }
    if (st === "end") {
      openEndScreen();
    }
  };

  ref.on("value", handler);
  statusUnsub = () => ref.off("value", handler);
}


// ===============================
// 画面描画（001〜012 など）
// ===============================
function renderGameUI(players, gameConfig, entryPlayers){
  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return; // まだDBにいない等

  // 001 自分の名前
  setText("myName", entryPlayers[myPid]?.name ?? "不明");

  // 012 自分のpoint（大きく）
  const myPoint = Number(my.point ?? 0);
  setText("myPoint", myPoint);

  // 002 リーチ棒本数
  setText("riichiCount", Number(gameConfig.riichiStickCount ?? 0));

  // 相手枠を初期化
  const slots = { N:null, W:null, S:null };
  for (const [pid, p] of Object.entries(players)){
    if (!p?.direction) continue;
    if (pid === myPid) continue;
    const rel = toRelative(my.direction, p.direction);
    if (rel) slots[rel] = { pid, p };
  }

  // N/W/S へ反映（003〜011）
  // 北枠
  renderOpponentSlot("N", slots.N, entryPlayers, myPoint);
  // 西枠
  renderOpponentSlot("W", slots.W, entryPlayers, myPoint);
  // 南枠
  renderOpponentSlot("S", slots.S, entryPlayers, myPoint);
}

function renderOpponentSlot(rel, slot, entryPlayers, myPoint){
  const nameId  = rel === "N" ? "nameN"  : rel === "W" ? "nameW"  : "nameS";
  const pointId = rel === "N" ? "pointN" : rel === "W" ? "pointW" : "pointS";
  const diffId  = rel === "N" ? "diffN"  : rel === "W" ? "diffW"  : "diffS";

  if (!slot){
    setText(nameId, "-");
    setText(pointId, "-");
    setText(diffId, "-");
    return;
  }

  const { pid, p } = slot;
  const nm = entryPlayers[pid]?.name ?? "不明";
  const pt = Number(p.point ?? 0);

  setText(nameId, nm);
  setText(pointId, pt);
  setDiff(diffId, myPoint - pt);
}

// ===============================
// 013 リーチ：リーチ棒+1 / 自分point-1000
// ===============================
async function onRiichiAdd(){
  const cfgRef = db.ref(`rooms/${currentRoomId}/gameConfig/riichiStickCount`);
  const myRef  = db.ref(`rooms/${currentRoomId}/players/${currentGameInfo.playerId}/point`);
  await cfgRef.transaction(v => (Number(v||0) + 1));
  await myRef.transaction(v => (Number(v||0) - 1000));
}

// ===============================
// 014 リーチ棒受取：自分point += 本数*1000 / リーチ棒0
// ===============================
async function onRiichiTake(){
  const cfgRef = db.ref(`rooms/${currentRoomId}/gameConfig/riichiStickCount`);
  const myRef  = db.ref(`rooms/${currentRoomId}/players/${currentGameInfo.playerId}/point`);

  const snap = await cfgRef.once("value");
  const cnt = Number(snap.val() || 0);
  if (cnt <= 0) return;

  await myRef.transaction(v => (Number(v||0) + cnt * 1000));
  await cfgRef.set(0);
}

// ===============================
// 019-021 送り先選択（常にアクティブ）
// ===============================
async function selectRecipient(rel){
  // rel: 'N'|'W'|'S'
  selectedRecipient = rel;
  sendAmountValue = 0;
  setText("sendAmount", "0");

  // 現在の相手を解決して 015 に表示
  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const eSnap = await db.ref(`systemConfig/entryPlayers`).once("value");
  const players = pSnap.val() || {};
  const entryPlayers = eSnap.val() || {};

  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return;

  let targetPid = null;
  for (const [pid, p] of Object.entries(players)){
    if (pid === myPid) continue;
    const r = toRelative(my.direction, p.direction);
    if (r === rel) { targetPid = pid; break; }
  }

  setText("sendToName", targetPid ? (entryPlayers[targetPid]?.name ?? "不明") : "-");
}

// ===============================
// 022-026 金額加算（015が出ている場合に有効、という仕様に近づける）
// ===============================
function addAmount(amount){
  if (!selectedRecipient) return; // 送り先未選択なら何もしない
  sendAmountValue += amount;
  setText("sendAmount", String(sendAmountValue));
}

// ===============================
// 017 取消：送り先/金額リセット
// ===============================
function cancelTransfer(){
  selectedRecipient = null;
  sendAmountValue = 0;
  setText("sendToName", "-");
  setText("sendAmount", "0");
}

// ===============================
// 018 確定：自分→相手へ point 移動
// 015 の相手に 016 の点数を移動
// ===============================
async function confirmTransfer(){
  if (!selectedRecipient) return;
  if (sendAmountValue <= 0) return;

  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = pSnap.val() || {};
  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return;

  // 相手pid解決
  let targetPid = null;
  for (const [pid, p] of Object.entries(players)){
    if (pid === myPid) continue;
    const r = toRelative(my.direction, p.direction);
    if (r === selectedRecipient) { targetPid = pid; break; }
  }
  if (!targetPid) return;

  const myPointRef = db.ref(`rooms/${currentRoomId}/players/${myPid}/point`);
  const tgPointRef = db.ref(`rooms/${currentRoomId}/players/${targetPid}/point`);

  // 同時更新（transactionで安全寄りに）
  await myPointRef.transaction(v => Number(v||0) - sendAmountValue);
  await tgPointRef.transaction(v => Number(v||0) + sendAmountValue);

  cancelTransfer();
}

// ===============================
// 対局終了ボタン
// ===============================
async function endGame() {
  const myPid = currentGameInfo.playerId;
  if (!myPid) return;

  // 自分を calculating に
  await db.ref(`rooms/${currentRoomId}/players/${myPid}/status`).set("calculating");

  // ★反映後の players を取り直す
  const playersSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = playersSnap.val() || {};

  const calcCount = Object.values(players).filter(p => p?.status === "calculating").length;
  const need = (currentRule === "3") ? 3 : 4;

  if (calcCount >= need) {
    const statusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
    await statusRef.transaction(cur => {
      // end なら触らない
      if (cur === "end") return;
      // すでに calculating でも触らない
      if (cur === "calculating") return;
      // waiting/playing どちらでも calculating にする
      return "calculating";
    });
  }

  alert("対局終了を送信しました。");
}




let calcUnsub = null;

function openCalculatingScreen() {
  // 画面切替
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  playerSetupScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  playerSelectScreen?.classList.add("hidden");
  gameScreen?.classList.add("hidden");
  calculatingScreen.classList.remove("hidden");

  subscribeCalculating();
}

function subscribeCalculating() {
  if (!currentRoomId) return;

  if (calcUnsub) calcUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);
    renderCalculatingUI(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
    checkAllEndAndClose(pSnap.val() || {}, cSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  calcUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
}


function resolvePosPids(players) {
  const myPid = currentGameInfo.playerId;
  const myDir = currentGameInfo.direction;
  const out = { ME: myPid, N: null, W: null, S: null };

  for (const [pid, p] of Object.entries(players)) {
    if (!p?.direction) continue;
    if (pid === myPid) continue;

    const rel = toRelative(myDir, p.direction); // 'N'|'W'|'S' を返すやつ
    if (rel) out[rel] = pid;
  }
  return out;
}


function calcScoreUnits(point, returnPoint) {
  return Math.ceil((Number(point || 0) - Number(returnPoint || 0)) / 1000);
}


function renderCalculatingUI(players, gameConfig, entryPlayers) {
  const pos = resolvePosPids(players);
  const returnPoint = Number(gameConfig.returnPoint || 0);

  // 4人分（ME/N/W/S）を配列化（存在しない席は除外）
  const list = ["ME","N","W","S"]
    .map(k => ({ k, pid: pos[k], p: pos[k] ? players[pos[k]] : null }))
    .filter(x => x.pid && x.p);

  // 名前表示（方角 + name）
  const nameOf = (pid) => entryPlayers[pid]?.name ?? "不明";
  const dirOf  = (pid) => players[pid]?.direction ?? "-";

  // 表示：005/006/007/008
  // ★縦並び（innerHTML）
  if (pos.N)  document.getElementById("calcTopName").innerHTML   = `<div>${dirOf(pos.N)}家</div><div>${nameOf(pos.N)}</div>`;
  if (pos.W)  document.getElementById("calcLeftName").innerHTML  = `<div>${dirOf(pos.W)}家</div><div>${nameOf(pos.W)}</div>`;
  if (pos.S)  document.getElementById("calcRightName").innerHTML = `<div>${dirOf(pos.S)}家</div><div>${nameOf(pos.S)}</div>`;
  if (pos.ME) document.getElementById("calcMyName").innerHTML    = `<div>${dirOf(pos.ME)}家</div><div>${nameOf(pos.ME)}</div>`;;

  // まず②の計算（全員分）
  const base = {};
  for (const x of list) {
    const u = calcScoreUnits(x.p.point, returnPoint);
    base[x.k] = u + (x.p.yakitoriFlg === true ? -10 : 0);
  }

  // トップ判定は point の最大
  let topK = null;
  let topPoint = -Infinity;
  for (const x of list) {
    const pt = Number(x.p.point || 0);
    if (pt > topPoint) { topPoint = pt; topK = x.k; }
  }

  // ①トップは「他人合計×-1」
  if (topK) {
    const othersSum = Object.entries(base)
      .filter(([k]) => k !== topK)
      .reduce((acc, [,v]) => acc + Number(v||0), 0);

    base[topK] = -1 * othersSum;
  }

  // 表示：009/010/011/012
  setText("calcTopScore",  pos.N  ? String(base["N"] ?? "-")  : "-");  // 010
  setText("calcLeftScore", pos.W  ? String(base["W"] ?? "-")  : "-");  // 009
  setText("calcRightScore",pos.S  ? String(base["S"] ?? "-")  : "-");  // 011
  setText("calcMyScore",   pos.ME ? String(base["ME"] ?? "-") : "-");  // 012

  // 001-004 ヤキトリボタン表示（trueなら「ヤキトリ」、falseなら空表示）
  setYakitoriButton("btnYakitoriTop",   pos.N,  players);
  setYakitoriButton("btnYakitoriLeft",  pos.W,  players);
  setYakitoriButton("btnYakitoriRight", pos.S,  players);
  setYakitoriButton("btnYakitoriMe",    pos.ME, players);

  // rooms/{roomId}/gameConfig/status == end の場合ボタン非活性
  const isRoomEnd = (gameConfig.status === "end");

  // player/{id}/status == "end" の人はヤキトリ操作不可（個別判定）
  const isPlayerEnd = (pid) => !!pid && players?.[pid]?.status === "end";

  // 集計中画面では「自分(ME)以外のヤキトリボタンは操作不可」
  const myPid = pos.ME;

  const yakitoriMap = [
    ["btnYakitoriTop",   pos.N],
    ["btnYakitoriLeft",  pos.W],
    ["btnYakitoriRight", pos.S],
    ["btnYakitoriMe",    pos.ME],
  ];

  for (const [btnId, pid] of yakitoriMap) {
    const b = document.getElementById(btnId);
    if (!b) continue;

    const isOther = !!pid && pid !== myPid; // 自分以外
    b.disabled = isRoomEnd || isPlayerEnd(pid) || isOther;
  }

  // 集計完了ボタンは部屋endで無効化
  const endBtn = document.getElementById("btnCalcEnd");
  if (endBtn) endBtn.disabled = isRoomEnd;

}

function computeScoresForRoom(players, gameConfig) {
  const returnPoint = Number(gameConfig.returnPoint || 0);

  // 参加者だけ抽出（directionがある人）
  const active = Object.entries(players || {})
    .filter(([pid, p]) => p?.direction) // 参加者のみ
    .map(([pid, p]) => ({ pid, p }));

  if (active.length === 0) return {};

  // ②：ceil((point-returnPoint)/1000) + (yakitoriFlg===true ? -10 : 0)
  const base = {};
  for (const { pid, p } of active) {
    const u = Math.ceil((Number(p.point || 0) - returnPoint) / 1000);
    base[pid] = u + (p.yakitoriFlg === true ? -10 : 0);
  }

  // ①：point最大の人をトップとし、他人の合計×-1
  let topPid = active[0].pid;
  let topPoint = Number(active[0].p.point || 0);
  for (const { pid, p } of active) {
    const pt = Number(p.point || 0);
    if (pt > topPoint) { topPoint = pt; topPid = pid; }
  }

  const othersSum = Object.entries(base)
    .filter(([pid]) => pid !== topPid)
    .reduce((acc, [,v]) => acc + Number(v || 0), 0);

  base[topPid] = -1 * othersSum;

  return base; // { pid: score, ... }
}

function setYakitoriButton(btnId, pid, players) {
  const btn = document.getElementById(btnId);
  if (!btn) return;
  if (!pid || !players[pid]) { btn.textContent = "-"; btn.disabled = true; return; }

  const flg = players[pid].yakitoriFlg === true;
  btn.textContent = flg ? "ヤキトリ" : ""; // 仕様どおり
  btn.disabled = false;
}


async function toggleYakitoriByPos(which) {
  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = pSnap.val() || {};
  const pos = resolvePosPids(players);

  const pid = (which === "ME") ? pos.ME : pos[which];
  if (!pid) return;

  const ref = db.ref(`rooms/${currentRoomId}/players/${pid}/yakitoriFlg`);
  const cur = players[pid]?.yakitoriFlg === true;
  await ref.set(!cur);
}

async function finishCalculating() {
  const pid = currentGameInfo.playerId;
  if (!pid) return;
  await db.ref(`rooms/${currentRoomId}/players/${pid}/status`).set("end");
  alert("集計完了を送信しました。");
}


async function checkAllEndAndClose(players, gameConfig) {
  if (!currentRoomId) return;

  // すでに終了確定済みなら何もしない（多重実行防止）
  if (gameConfig.status === "end") return;

  const endCount = Object.values(players || {}).filter(p => p?.status === "end").length;
  const need = (currentRule === "3") ? 3 : 4;
  if (endCount < need) return;

  // ★最後の人が複数同時に入ることがあるので status を先に確認してガード
  const statusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  const stSnap = await statusRef.once("value");
  const st = stSnap.val();
  if (st === "end") return;

  // score計算（表示と同じ）
  const scores = computeScoresForRoom(players, gameConfig);

  // players/{pid}/score に一括反映（multi-location update）
  const updates = {};
  for (const [pid, sc] of Object.entries(scores)) {
    updates[`rooms/${currentRoomId}/players/${pid}/score`] = sc;
  }

  // ついでに status を end にする（集計完了の確定）
  updates[`rooms/${currentRoomId}/gameConfig/status`] = "end";

  await db.ref().update(updates);

  alert("全員の集計完了が揃いました。スコアを保存しました（対局終了画面は未作成）");
  openEndScreen();
}



// ===============================
// 対局終了画面：リアルタイム購読
// ===============================
let endUnsub = null;

function openEndScreen() {
  // 画面切替
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  playerSetupScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  playerSelectScreen?.classList.add("hidden");
  gameScreen?.classList.add("hidden");
  calculatingScreen?.classList.add("hidden");
  endScreen.classList.remove("hidden");

  subscribeEndScreen();
}

function subscribeEndScreen() {
  if (!currentRoomId) return;

  if (endUnsub) endUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);

    renderEndScreen(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  endUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
}

function renderEndScreen(players, gameConfig, entryPlayers) {
  // 001 ルール表示
  const ruleMap = { "3":"3麻", "3r4":"3麻4人回", "4":"4麻" };
  const ruleText = ruleMap[gameConfig.rule] || gameConfig.rule || "-";
  const ruleBtn = document.getElementById("endRuleBtn");
  if (ruleBtn) ruleBtn.textContent = ruleText;

  // 002,003 原点/返し点
  setText("endStartPoint", gameConfig.startPoint ?? "-");
  setText("endReturnPoint", gameConfig.returnPoint ?? "-");

  // 参加者（directionがある人）だけを対象に、score降順で並べる
  const list = Object.entries(players || {})
    .filter(([pid, p]) => p?.direction) // 参加者
    .map(([pid, p]) => ({
      pid,
      name: entryPlayers?.[pid]?.name ?? "不明",
      score: (p.score ?? null),
      yakitori: (p.yakitoriFlg === true),
      point: Number(p.point ?? 0),
    }))
    // scoreが未計算（null）の人は最後に回す
    .sort((a, b) => {
      const as = (a.score === null || a.score === undefined) ? -Infinity : Number(a.score);
      const bs = (b.score === null || b.score === undefined) ? -Infinity : Number(b.score);
      if (bs !== as) return bs - as;
      // 同点なら point で安定化（任意）
      return (b.point - a.point);
    });

  // 3麻なら4位枠を隠す（見た目の要望がある場合）
  const is3 = (gameConfig.rule === "3");
  const rank4Box = document.getElementById("rank4Box");
  if (rank4Box) rank4Box.style.display = is3 ? "none" : "block";

  // 004-011, 012-015 埋める
  const ranks = [
    { nameId:"rank1Name", scoreId:"rank1Score", yId:"rank1Yakitori" },
    { nameId:"rank2Name", scoreId:"rank2Score", yId:"rank2Yakitori" },
    { nameId:"rank3Name", scoreId:"rank3Score", yId:"rank3Yakitori" },
    { nameId:"rank4Name", scoreId:"rank4Score", yId:"rank4Yakitori" },
  ];

  const showCount = is3 ? 3 : 4;

  for (let i = 0; i < ranks.length; i++) {
    const r = ranks[i];
    const row = list[i];

    if (i >= showCount) {
      // 3麻の4位は非表示想定だが、念のためクリア
      setText(r.nameId, "-");
      setText(r.scoreId, "-");
      setText(r.yId, "");
      continue;
    }

    if (!row) {
      setText(r.nameId, "-");
      setText(r.scoreId, "-");
      setText(r.yId, "");
      continue;
    }

    setText(r.nameId, row.name);                 // 004-007
    setText(r.scoreId, row.score ?? "-");        // 008-011
    setText(r.yId, row.yakitori ? "ヤキトリ" : ""); // 012-015
  }
}

// 画面離脱時は購読解除
function stopAllSubscriptions() {
  if (roomsUnsub) roomsUnsub();
  if (gameStateUnsub) gameStateUnsub();
  if (calcUnsub) calcUnsub();
  if (endUnsub) endUnsub();
}


// ------------------- DB削除 -------------------
function deleteRoom(roomId) {
  if(!confirm("このルームを削除しますか？")) return;

  // ルーム自体を削除（購読で一覧は自動更新）
  db.ref(`rooms/${roomId}`).remove();
}



// ================= 戻る =================
function backToPlayerSetup() {
  addPlayerScreen.classList.add("hidden");
  playerSetupScreen.classList.remove("hidden");
  loadEntryPlayers();
}

function backToRoomList() {
  if (calcUnsub) calcUnsub();
  saveAppState("roomList");
  // rejoinScreen.classList.add("hidden");
  playerSetupScreen.classList.add("hidden");
  gameScreen.classList.add("hidden");
  playerSelectScreen.classList.add("hidden");
  calculatingScreen.classList.add("hidden");
  endScreen.classList.add("hidden");
  roomListScreen.classList.remove("hidden");
  loadRooms();
  subscribeRooms();
  if (statusUnsub) statusUnsub();
}


// sessionStorageに必要な情報格納
function saveAppState(screen) {
  sessionStorage.setItem(APP_STATE_KEY, JSON.stringify({
    loggedIn: true,
    screen,
    roomId: currentRoomId ?? null,
    currentGameInfo: currentGameInfo ?? {}
  }));
}

window.addEventListener("load", async () => {

  // ===== PWA: Service Worker 登録（ここに追加）=====
  if ("serviceWorker" in navigator) {
    try {
      await navigator.serviceWorker.register("/sw.js");
      console.log("SW registered");
    } catch (e) {
      console.log("SW register failed:", e);
    }
  }

  const stateStr = sessionStorage.getItem(APP_STATE_KEY);
  if (!stateStr) return;

  let state;
  try {
    state = JSON.parse(stateStr);
  } catch {
    sessionStorage.removeItem(APP_STATE_KEY);
    return;
  }

  if (!state.loggedIn) return;

  const { screen, roomId } = state;
  currentRoomId = roomId;

  // まず全部隠す（重要）
  loginScreen.classList.add("hidden");
  roomListScreen.classList.add("hidden");
  playerSetupScreen.classList.add("hidden");
  gameScreen.classList.add("hidden");

  // ルーム一覧画面へ遷移
  if (screen === "roomList") {
    roomListScreen.classList.remove("hidden");
    enterRoom();
  }

  // 参加者設定画面へ遷移
  if (screen === "playerSetupScreen") {
    enterRoom();
  }

  // プレイヤー追加画面へ遷移
  if (screen === "addPlayerScreen") {
    enterRoom();
  }

  if (screen === "gameScreen") {
    enterRoom();
  }
});


</script>
</body>
</html>

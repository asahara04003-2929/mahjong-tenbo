<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<link rel="manifest" href="/manifest.json">
<link rel="stylesheet" href="style.css">

<meta name="theme-color" content="#CFEEC0">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">

<script src="firebaseConfig.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<style>
.hidden { display:none; }
.room { border:1px solid #ccc; margin:6px 0; padding:6px; }
select { margin-left:6px; }
</style>
</head>

<body>

<!-- ========================================= -->
<!-- ログイン -->
<!-- ========================================= -->
<div id="loginScreen">
  <input id="loginPass" placeholder="パスワード">
  <button onclick="login()">ログイン</button>
</div>

<!-- ========================================= -->
<!-- プレイヤー設定（新規） -->
<!-- ========================================= -->
<div id="playerConfigScreen" class="hidden">
  <h2>プレイヤー設定</h2>

  <!-- 001: プルダウン -->
  <div style="margin:12px 0;">
    <label>プレイヤー：</label>
    <select id="playerConfigSelect"></select>
  </div>

  <!-- 002: 設定完了 -->
  <button id="btnPlayerConfigDone" onclick="completePlayerConfig()">設定完了</button>

  <div style="height:24px;"></div>

  <!-- 004: ルーム一覧へ戻る -->
  <div style="margin-top:12px;">
    <button onclick="goRoomList()">ルーム一覧へ戻る</button>
  </div>

  <div id="playerConfigMsg" style="margin-top:10px; color:#b00;"></div>
</div>


<!-- ========================================= -->
<!-- ルーム一覧 -->
<!-- ========================================= -->
<div id="roomListScreen" class="hidden">
  <h2>ルーム一覧</h2>
  <!-- 上部ボタン（設計図：001,009） -->
  <div style="display:flex; gap:10px; margin:10px 0;">
    <button onclick="openRoomCreateScreen()">ルーム作成</button>  <!-- 001 -->
    <button onclick="openPlayerConfigScreen()">プレイヤー設定</button>
    <button onclick="openAddPlayerFromRoomList()">プレイヤー追加</button> <!-- 009 -->
  </div>
  <div id="roomList"></div>
</div>

<!-- ========================================= -->
<!-- ルーム作成（新規） -->
<!-- ========================================= -->
<div id="roomCreateScreen" class="hidden">
  <h2>ルーム作成</h2>

  <div style="margin:10px 0;">
    <div style="margin-bottom:8px;">ルール：</div>
    <label><input type="radio" name="create_rule" value="3" checked>3麻</label>
    <label style="margin-left:10px;"><input type="radio" name="create_rule" value="3r4">3麻4人回し</label>
    <label style="margin-left:10px;"><input type="radio" name="create_rule" value="4">4麻</label>
  </div>

  <div style="margin:10px 0;">
    <label>原点：</label>
    <input type="number" id="createStartPoint" step="5000" value="45000" style="width:120px;">
  </div>

  <div style="margin:10px 0;">
    <label>返し点：</label>
    <input type="number" id="createReturnPoint" step="5000" value="50000" style="width:120px;">
  </div>

  <div style="margin:14px 0;">
    <div style="margin-bottom:8px;">席順</div>

    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">東：</div>
      <select id="createSeatE"></select>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">南：</div>
      <select id="createSeatS"></select>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">西：</div>
      <select id="createSeatW"></select>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">北：</div>
      <select id="createSeatN"></select>
    </div>
  </div>

  <div style="display:flex; gap:10px; margin-top:14px;">
    <button id="btnCreateRoomDo" onclick="createRoomFromCreateScreen()">ルーム作成</button> <!-- 008 -->
    <button onclick="backToRoomList()">戻る</button>
  </div>

  <div id="roomCreateMsg" style="margin-top:10px; color:#b00;"></div>
</div>

<!-- ========================================= -->
<!-- 参加者設定 -->
<!-- ========================================= -->
<div id="playerSetupScreen" class="hidden">
  <h2>参加者設定</h2>
  <div id="seatArea"></div>
  <button onclick="openAddPlayer()">プレイヤー追加</button>
  <button onclick="backToRoomList()">戻る</button>
  <button id="startBtn" disabled onclick="renderPlayerSelect()">対局開始</button>
</div>

<!-- ========================================= -->
<!-- プレイヤー追加 -->
<!-- ========================================= -->
<div id="addPlayerScreen" class="hidden">
  <h2>プレイヤー追加</h2>
  <input id="newPlayerName" placeholder="名前">
  <button onclick="addPlayer()">登録</button>
  <button onclick="backToPlayerSetup()">戻る</button>
</div>

<!-- ========================================= -->
<!-- プレイヤー選択画面 -->
<!-- ========================================= -->
<div id="playerSelectScreen" class="hidden">
  <h2>自席を選択してください。</h2>

  <div id="playerSelectTable" style="display: grid; grid-template-columns: 1fr 1fr 1fr; text-align: center; row-gap: 10px; column-gap: 10px; justify-items: center;">
    <!-- 東 -->
    <div></div>
    <div id="player-east"></div>
    <div></div>

    <!-- 南/北 -->
    <div id="player-south"></div>
    <div></div>
    <div id="player-north"></div>

    <!-- 西 -->
    <div></div>
    <div id="player-west"></div>
    <div></div>
  </div>

  <br>
  <button onclick="backToRoomList()">一覧画面へ戻る</button>
</div>


<!-- ========================================= -->
<!-- 対局画面 -->
<!-- ========================================= -->
<div id="gameScreen" class="hidden">
  <h2 class="gs-title">対局中</h2>
  <div class="gs-layout">
    <!-- =========================
         左：卓（点数表示）
    ========================== -->
    <section class="gs-tableWrap">


      <div id="gameTable" class="gs-table">
        <!-- 北(相手) -->
        <div class="gs-seat gs-north">
          <div class="gs-name" id="nameN">-</div>
          <div class="gs-point" id="pointN">-</div>
          <div class="gs-diff" id="diffN">-</div>
        </div>

        <!-- 西(相手) -->
        <div class="gs-seat gs-west">
          <div class="gs-name" id="nameW">-</div>
          <div class="gs-point" id="pointW">-</div>
          <div class="gs-diff" id="diffW">-</div>
        </div>

        <!-- 東(自分) -->
        <div class="gs-seat gs-self">
          <div class="gs-selfName" id="myName">-</div>
          <div class="gs-selfPoint" id="myPoint">-</div>
        </div>

        <!-- 南(相手) -->
        <div class="gs-seat gs-south">
          <div class="gs-name" id="nameS">-</div>
          <div class="gs-point" id="pointS">-</div>
          <div class="gs-diff" id="diffS">-</div>
        </div>
      </div>
    </section>

    <!-- =========================
         右：操作パネル
    ========================== -->
    <aside class="gs-panel">
      <!-- リーチ系 -->
      <div class="gs-row">
        <button class="gs-btn gs-btnWide" id="btnRiichiAdd" onclick="onRiichiAdd()">リーチ</button>
        <button class="gs-btn" id="btnRiichiTake" onclick="onRiichiTake()">受取</button>
      </div>
      <div class="gs-row">
      <!-- 対局終了 -->
        <button class="gs-btn gs-btnDanger" id="btnEndGame" onclick="endGame()">対局終了</button>
        <button class="gs-btn" onclick="backToRoomList()">ルーム一覧へ戻る</button>
      </div>
    </aside>
  </div>
  <!-- リーチ棒表示（左上） -->
  <div id="riichiHUD" class="riichiHUD" aria-label="リーチ棒">
    <span class="riichiStick" aria-hidden="true"></span>
    <span class="riichiTimes">×<span id="riichiCount">0</span></span>
  </div>
</div>


<!-- =========================
     送金ボトムシート（下からせり出し）
========================= -->
<div id="transferOverlay" class="ts-overlay hidden" onclick="closeTransferSheet()"></div>

<div id="transferSheet" class="ts-sheet hidden" role="dialog" aria-modal="true">
  <div class="ts-handle"></div>

  <div class="ts-header">
    <div class="ts-title">送金</div>
    <button class="ts-close" onclick="closeTransferSheet()">×</button>
  </div>

  <!-- 送金状況（元の赤枠の上部） -->
  <div class="gs-card">
    <div class="gs-cardRow">
      <div class="gs-cardLabel">支払先：</div>
      <div class="gs-cardValue"><span id="sendToName">-</span></div>
    </div>
    <div class="gs-cardRow">
      <div class="gs-cardLabel">支払点数：</div>
      <div class="gs-cardValue"><span id="sendAmount">0</span></div>
    </div>
  </div>

  <!-- 加算ボタン -->
  <div class="gs-amountGrid">
    <button class="gs-btn" onclick="addAmount(10000)">10000</button>
    <button class="gs-btn" onclick="addAmount(1000)">1000</button>
    <button class="gs-btn" onclick="addAmount(100)">100</button>
    <button class="gs-btn" onclick="addAmount(5000)">5000</button>
    <button class="gs-btn" onclick="addAmount(500)">500</button>
    <button class="gs-btn gs-btnSub" onclick="cancelTransfer()">クリア</button>
  </div>

  <!-- 確定/取消 -->
  <div class="gs-row">
    <button class="gs-btn gs-btnPrimary" id="btnConfirm" onclick="confirmTransfer()">確定</button>
    <button class="gs-btn" id="btnCancel" onclick="cancelTransfer()">取消</button>
  </div>
</div>


<!-- ========================================= -->
<!-- 集計中画面 -->
<!-- ========================================= -->
<div id="calculatingScreen" class="hidden">
  <h2>集計</h2>

  <!-- 006（上） -->
  <div id="calcTopName" style="text-align:center; margin-bottom:10px;">-</div>

  <!-- 002（上のボタン） -->
  <div style="text-align:center; margin-bottom:6px;">
    <button id="btnYakitoriTop" onclick="toggleYakitoriByPos('N')">-</button> <!-- 002 -->
  </div>

  <!-- 010（上のスコア表示） -->
  <div id="calcTopScore" style="text-align:center; margin-bottom:18px;">-</div>

  <!-- 左右（001/003 ボタン、005/007 名前、009/011 スコア） -->
  <div style="display:flex; justify-content:space-between; align-items:center; margin:16px 0;">
    <div style="width:40%; text-align:left;">
      <div id="calcLeftName">-</div> <!-- 005 -->
      <button id="btnYakitoriLeft" onclick="toggleYakitoriByPos('W')">-</button> <!-- 001 -->
      <div id="calcLeftScore">-</div> <!-- 009 -->
    </div>

    <div style="width:40%; text-align:right;">
      <div id="calcRightName">-</div> <!-- 007 -->
      <button id="btnYakitoriRight" onclick="toggleYakitoriByPos('S')">-</button> <!-- 003 -->
      <div id="calcRightScore">-</div> <!-- 011 -->
    </div>
  </div>

  <!-- 自分（008 名前 / 004 ヤキトリボタン / 012 スコア） -->
  <div style="text-align:center; margin-top:20px;">
    <div id="calcMyName">-</div> <!-- 008 -->
    <button id="btnYakitoriMe" onclick="toggleYakitoriByPos('ME')">-</button> <!-- 004 -->
    <div id="calcMyScore" style="margin-top:6px;">-</div> <!-- 012 -->
  </div>

  <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
    <button id="btnCalcEnd" onclick="finishCalculating()">集計完了</button> <!-- 013 -->
    <button onclick="backToRoomList()">ルーム一覧へ戻る</button> <!-- 014 -->
  </div>
</div>

<!-- ========================================= -->
<!-- 対局終了画面 -->
<!-- ========================================= -->
<div id="endScreen" class="hidden">
  <h2>対局終了</h2>

  <div style="margin-bottom:12px;">
    ルール：<button id="endRuleBtn" disabled>-</button> <!-- 001 -->
    <div>原点：<span id="endStartPoint">-</span></div>  <!-- 002 -->
    <div>返し点：<span id="endReturnPoint">-</span></div> <!-- 003 -->
  </div>

  <!-- 順位表示 -->
  <div id="endRankGrid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:12px; text-align:center;">
    <!-- 1位 -->
    <div>
      <div>1位</div>
      <div id="rank1Name">-</div>  <!-- 004 -->
      <div id="rank1Score">-</div> <!-- 008 -->
      <div id="rank1Yakitori"></div> <!-- 012 -->
    </div>

    <!-- 2位 -->
    <div>
      <div>2位</div>
      <div id="rank2Name">-</div>  <!-- 005 -->
      <div id="rank2Score">-</div> <!-- 009 -->
      <div id="rank2Yakitori"></div> <!-- 013 -->
    </div>

    <!-- 3位 -->
    <div>
      <div>3位</div>
      <div id="rank3Name">-</div>  <!-- 006 -->
      <div id="rank3Score">-</div> <!-- 010 -->
      <div id="rank3Yakitori"></div> <!-- 014 -->
    </div>

    <!-- 4位 -->
    <div id="rank4Box">
      <div>4位</div>
      <div id="rank4Name">-</div>  <!-- 007 -->
      <div id="rank4Score">-</div> <!-- 011 -->
      <div id="rank4Yakitori"></div> <!-- 015 -->
    </div>
  </div>

  <div style="margin-top:18px; text-align:center;">
    <button onclick="backToRoomList()">ルーム一覧へ戻る</button> <!-- 016 -->
  </div>
</div>


<script>
// ============================================
//                  スクリプト
// ================= Firebase =================
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
firebase.initializeApp(window.firebaseConfig);
const db = firebase.database();

// ===== DOM参照を明示（idの自動グローバルに依存しない）=====
const transferSheet   = document.getElementById("transferSheet");
const transferOverlay = document.getElementById("transferOverlay");
const loginScreen      = document.getElementById("loginScreen");
const playerConfigScreen = document.getElementById("playerConfigScreen");
const roomListScreen   = document.getElementById("roomListScreen");
const roomCreateScreen = document.getElementById("roomCreateScreen");
const playerSetupScreen= document.getElementById("playerSetupScreen");
const addPlayerScreen  = document.getElementById("addPlayerScreen");
const playerSelectScreen = document.getElementById("playerSelectScreen");
const gameScreen       = document.getElementById("gameScreen");
const calculatingScreen= document.getElementById("calculatingScreen");
const endScreen        = document.getElementById("endScreen");

const loginPass        = document.getElementById("loginPass");
const roomList         = document.getElementById("roomList");

const startBtn         = document.getElementById("startBtn");
const seatArea         = document.getElementById("seatArea");
const newPlayerName    = document.getElementById("newPlayerName");


const APP_STATE_KEY = "mahjong_app_state";

// ============== 端末/プレイヤー紐づけ用（追加） ==============
let myDeviceId = null;   // UUID
let myPlayerId = null;   // deviceMapから逆引きしたplayerId

// ================= 状態 =================
let currentRoomId = null;
let currentRule = null;
let currentGameInfo = {
  playerId: null,
  direction: null,
  status: null
}

// プルダウン用
let entryPlayers = {};
let seats = { 東:"", 南:"", 西:"", 北:"" };

const RULES = {"3":"３麻", "3r4":"３麻４人回", "4":"4麻"};
const GAME_STATUS = {"waiting": "待機中","playing": "対局中", "calculating": "集計中", "end":"対局終了"}

// 全画面非表示
function hideAllScreens() {
  loginScreen.classList.add("hidden");
  playerConfigScreen?.classList.add("hidden");
  roomListScreen.classList.add("hidden");
  roomCreateScreen?.classList.add("hidden");
  playerSetupScreen.classList.add("hidden");
  addPlayerScreen.classList.add("hidden");
  playerSelectScreen.classList.add("hidden");
  gameScreen.classList.add("hidden");
  calculatingScreen.classList.add("hidden");
  endScreen.classList.add("hidden");

  // ★追加
  document.getElementById("playerConfigScreen")?.classList.add("hidden");
}

// 画面表示
function showScreen(id) {
  hideAllScreens();
  document.getElementById(id)?.classList.remove("hidden");
  saveAppState(id); // 画面IDをそのまま保存してOK（後で復帰）
}

// ================= ログイン =================
async function login() {
  const pass = (loginPass?.value ?? "").trim();

  if (!pass) {
    alert("パスワードを入力してください");
    return;
  }

  try {
    const snap = await db.ref("systemConfig/loginPass").once("value");

    if (!snap.exists()) {
      alert("DBに systemConfig/loginPass が存在しません。パスを確認してください。");
      return;
    }

    const dbPass = String(snap.val() ?? "").trim();

    // ★型違い（数値/文字列）でも一致できるように String 比較
    if (dbPass !== String(pass)) {
      alert("パスワードが違います。");
      return;
    }

    // 成功
    await bootstrapAfterLogin();

  } catch (e) {
    console.error("login error:", e);
    alert("Firebase読み取りに失敗しました。コンソールの login error を見てください。\n" + (e?.message ?? e));
  }
}


async function bootstrapAfterLogin() {
  loginScreen.classList.add("hidden");
  // 1) deviceId取得
  myDeviceId = getOrCreateDeviceId();
  if (!myDeviceId) {
    // まずここはほぼ起きないが念のため
    myPlayerId = null;
    await openPlayerConfigScreen("deviceIdが取得できません。再読み込みしてください。");
    return;
  }

  // 2) deviceMap/{deviceId} を参照
  const snap = await db.ref(`deviceMap/${myDeviceId}`).once("value");
  const map = snap.val();

  // 3) playerId取れればルーム一覧へ、取れなければプレイヤー設定へ
  if (map && map.playerId) {
    myPlayerId = map.playerId;
    showRoomListScreen();
    return;
  }

  myPlayerId = null;
  await openPlayerConfigScreen("");
}

const DEVICE_ID_KEY = "mahjong_device_id";

function getOrCreateDeviceId() {
  let id = localStorage.getItem(DEVICE_ID_KEY);
  if (id) return id;

  // crypto.randomUUID が使えるならそれを使う
  if (crypto?.randomUUID) {
    id = crypto.randomUUID();
  } else {
    // フォールバック（十分ユニーク）
    id = "xxxxxxxxyxxx4xxxyxxxxyxxxxxxxxxxx".replace(/[xy]/g, c => {
      const r = (Math.random() * 16) | 0;
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  localStorage.setItem(DEVICE_ID_KEY, id);
  return id;
}

async function openPlayerConfigScreen(msg) {
  showScreen("playerConfigScreen");

  const msgEl = document.getElementById("playerConfigMsg");
  if (msgEl) msgEl.textContent = msg || "";

  // entryPlayersをロードしてプルダウン作る
  const snap = await db.ref("systemConfig/entryPlayers").once("value");
  const list = snap.val() || {};

  const sel = document.getElementById("playerConfigSelect");
  sel.innerHTML = "";

  // 1件も無い場合
  const keys = Object.keys(list);
  if (keys.length === 0) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "プレイヤーが未登録です";
    sel.appendChild(opt);
    document.getElementById("btnPlayerConfigDone").disabled = true;
    return;
  }

  document.getElementById("btnPlayerConfigDone").disabled = false;

  // option作成
  for (const pid of keys) {
    const opt = document.createElement("option");
    opt.value = pid;
    opt.textContent = list[pid]?.name ?? pid;
    sel.appendChild(opt);
  }
}

async function completePlayerConfig() {
  const sel = document.getElementById("playerConfigSelect");
  const pid = sel?.value;

  if (!pid) {
    document.getElementById("playerConfigMsg").textContent = "プレイヤーを選択してください。";
    return;
  }

  // deviceIdが無ければ作る（基本ここには来ない）
  myDeviceId = myDeviceId || getOrCreateDeviceId();
  if (!myDeviceId) {
    document.getElementById("playerConfigMsg").textContent = "deviceIdを取得できません。";
    return;
  }

  const ref = db.ref(`deviceMap/${myDeviceId}`);
  const snap = await ref.once("value");
  const cur = snap.val();

  if (cur && cur.playerId) {
    // ★すでに紐づけ済みなら更新不要（仕様）
    myPlayerId = cur.playerId;
  } else {
    // 新規作成
    await ref.set({
      playerId: pid,
      createdAt: firebase.database.ServerValue.TIMESTAMP,
      lastRoomId: null
    });
    myPlayerId = pid;
  }

  // ルーム一覧へ
  showRoomListScreen();
}

let addPlayerReturnTo = null; // "playerConfig" or "playerSetup"

function openAddPlayerFromPlayerConfig() {
  addPlayerReturnTo = "playerConfig";
  showScreen("addPlayerScreen");
}

function openAddPlayer() {
  // 既存の参加者設定画面から呼ぶ場合
  addPlayerReturnTo = "playerSetup";
  playerSetupScreen.classList.add("hidden");
  addPlayerScreen.classList.remove("hidden");
  saveAppState("addPlayerScreen");
}

function backToPlayerSetup() {
  addPlayerScreen.classList.add("hidden");

  if (addPlayerReturnTo === "playerConfig") {
    openPlayerConfigScreen("");
    return;
  }

  playerSetupScreen.classList.remove("hidden");
  loadEntryPlayers();
}

function showRoomListScreen() {
  showScreen("roomListScreen");
  subscribeRooms();
}
function goRoomList() {
  // プレイヤー設定から戻るボタン用
  showRoomListScreen();
}


// ================= ルーム一覧 =================
function loadRooms() {
  roomList.innerHTML = "";

  // ヘッダー
  const header = document.createElement("div");
  header.style.fontWeight = "bold";
  header.style.display = "flex";
  header.style.gap = "10px";
  header.innerHTML = `
    <div style="width:150px;">ルームID</div>
    <div style="width:100px;">ルール</div>
    <div style="width:100px;">状態</div>
    <div style="width:100px;">待機人数</div>
    <div style="flex:1;">操作</div>
  `;
  roomList.appendChild(header);
}


// ===== ルーム一覧リアルタイム購読 =====
let roomsUnsub = null;

function subscribeRooms() {
  const ref = db.ref("rooms");

  if (roomsUnsub) roomsUnsub();

  const handler = (snap) => {
    try {
      const rooms = snap.val() || {};
      renderRoomList(rooms);
      if (roomList.children.length === 1) { // headerしかない
        const div = document.createElement("div");
        div.style.padding = "8px 0";
        div.textContent = "ルームがありません（または表示対象ステータスがありません）";
        roomList.appendChild(div);
      }
    } catch (e) {
      console.error("renderRoomList error:", e);
      alert("ルーム一覧描画でエラー。コンソールを確認してください。");
    }
  };

  const onError = (err) => {
    console.error("rooms subscribe error:", err);
    alert("rooms の読み取りに失敗しました。DB権限やパスを確認してください。");
  };

  ref.on("value", handler, onError);
  roomsUnsub = () => ref.off("value", handler);

  ref.once("value").then(handler).catch(onError);
}

function renderRoomList(rooms) {
  roomList.innerHTML = "";

  // ヘッダー
  const header = document.createElement("div");
  header.style.fontWeight = "bold";
  header.style.display = "flex";
  header.style.gap = "10px";
  header.innerHTML = `
    <div style="width:150px;">ルームID</div>
    <div style="width:100px;">ルール</div>
    <div style="width:100px;">状態</div>
    <div style="width:100px;">待機人数</div>
    <div style="flex:1;">操作</div>
  `;
  roomList.appendChild(header);

  const statusAllow = ["waiting","playing","calculating","end"];

  for (const id in rooms) {
    const r = rooms[id] || {};
    const status = r.gameConfig?.status ?? "-";
    if (!statusAllow.includes(status)) continue;

    const div = document.createElement("div");
    div.style.display = "flex";
    div.style.gap = "10px";
    div.style.borderBottom = "1px solid #ccc";
    div.style.padding = "4px 0";

    const playerCount = r.players
      ? Object.values(r.players).filter(p => p?.status === "playing").length
      : 0;

    const ruleText = RULES[r.gameConfig?.rule] || r.gameConfig?.rule || "-";
    const stText   = GAME_STATUS[status] || status;

    div.innerHTML = `
      <div style="width:150px;">${id}</div>
      <div style="width:100px;">${ruleText}</div>
      <div style="width:100px;">${stText}</div>
      <div style="width:100px;">${playerCount}</div>
      <div style="flex:1;">
        ${["waiting","playing","calculating"].includes(status) ? `<button onclick="enterRoom('${id}')">入室</button>` : ""}
        ${status === "end" ? `<button onclick="enterRoom('${id}'); openEndScreen();">結果</button>` : ""}
        ${status === "waiting" ? `<button onclick="deleteRoom('${id}')">削除</button>` : ""}
      </div>
    `;
    roomList.appendChild(div);
  }

  // 0件のときの表示
  if (roomList.children.length === 1) {
    const div = document.createElement("div");
    div.style.padding = "8px 0";
    div.textContent = "ルームがありません（または表示対象ステータスがありません）";
    roomList.appendChild(div);
  }
}


// ---------------------------
// ルーム作成画面（新規）
// ---------------------------
const createSeatIds = [
  ["東", "createSeatE"],
  ["南", "createSeatS"],
  ["西", "createSeatW"],
  ["北", "createSeatN"],
];

function openRoomCreateScreen() {
  showScreen("roomCreateScreen");
  loadEntryPlayersForCreate();
}

async function loadEntryPlayersForCreate() {
  const msgEl = document.getElementById("roomCreateMsg");
  if (msgEl) msgEl.textContent = "";

  const snap = await db.ref("systemConfig/entryPlayers").once("value");
  const list = snap.val() || {};

  // option生成（全席共通）
  for (const [, selId] of createSeatIds) {
    const sel = document.getElementById(selId);
    if (!sel) continue;

    sel.innerHTML = "";

    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "未選択";
    sel.appendChild(opt0);

    for (const [pid, p] of Object.entries(list)) {
      const opt = document.createElement("option");
      opt.value = pid;
      opt.textContent = p?.name ?? pid;
      sel.appendChild(opt);
    }

    sel.addEventListener("change", validateCreateRoomForm);
  }

  // ルール/点数も変更時に検証
  document.querySelectorAll("input[name=create_rule]").forEach(r => {
    r.addEventListener("change", validateCreateRoomForm);
  });
  document.getElementById("createStartPoint")?.addEventListener("input", validateCreateRoomForm);
  document.getElementById("createReturnPoint")?.addEventListener("input", validateCreateRoomForm);

  validateCreateRoomForm();
}

function getCreateRule() {
  return document.querySelector("input[name=create_rule]:checked")?.value || "3";
}

function validateCreateRoomForm() {
  const rule = getCreateRule();
  const need = (rule === "3") ? 3 : 4;

  const start = parseInt(document.getElementById("createStartPoint")?.value, 10) || 0;
  const ret   = parseInt(document.getElementById("createReturnPoint")?.value, 10) || 0;

  const picks = [];
  for (const [dir, selId] of createSeatIds) {
    const v = document.getElementById(selId)?.value || "";
    if (v) picks.push({ dir, pid: v });
  }

  const msgEl = document.getElementById("roomCreateMsg");
  const btn = document.getElementById("btnCreateRoomDo");

  // 原点 <= 返し点
  if (start > ret) {
    if (msgEl) msgEl.textContent = "原点は返し点以下にしてください。";
    if (btn) btn.disabled = true;
    return;
  }

  // 重複チェック
  const ids = picks.map(x => x.pid);
  const unique = new Set(ids);
  if (unique.size !== ids.length) {
    if (msgEl) msgEl.textContent = "同じプレイヤーが複数席にいます。";
    if (btn) btn.disabled = true;
    return;
  }

  // 人数チェック
  if (picks.length !== need) {
    if (msgEl) msgEl.textContent = `席を${need}人分選択してください。`;
    if (btn) btn.disabled = true;
    return;
  }

  if (msgEl) msgEl.textContent = "";
  if (btn) btn.disabled = false;
}

async function createRoomFromCreateScreen() {
  validateCreateRoomForm();
  const btn = document.getElementById("btnCreateRoomDo");
  if (btn?.disabled) return;

  const rule = getCreateRule();
  const startPoint  = parseInt(document.getElementById("createStartPoint")?.value, 10) || 45000;
  const returnPoint = parseInt(document.getElementById("createReturnPoint")?.value, 10) || 50000;

  // 選択席を集める
  const selected = [];
  for (const [dir, selId] of createSeatIds) {
    const pid = document.getElementById(selId)?.value || "";
    if (pid) selected.push({ dir, pid });
  }

  const need = (rule === "3") ? 3 : 4;
  if (selected.length !== need) return;

  // ルームID（既存と同じ形式）
  const d = new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const roomId = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;

  // players を組み立て
  const playersObj = {};
  for (const x of selected) {
    playersObj[x.pid] = {
      direction: x.dir,
      status: "waiting",
      point: startPoint,
      score: null,
      yakitoriFlg: true
    };
  }

  await db.ref(`rooms/${roomId}`).set({
    gameConfig: {
      startPoint,
      returnPoint,
      rule,
      status: "waiting",
      riichiStickCount: 0
    },
    players: playersObj,
    transferRequests: {},
    gameLogs: {}
  });

  // 作ったら一覧へ
  backToRoomList();
}

function openAddPlayerFromRoomList() {
  addPlayerReturnTo = "roomList";
  showScreen("addPlayerScreen");
}


// 参加者設定処理
function enterRoom(id) {
  saveAppState("playerSetupScreen");
  currentRoomId = id;

  // ルール取得
  db.ref(`rooms/${id}/gameConfig/rule`).once("value").then(s => {
    currentRule = s.val();

    // seats の初期化はここで1回だけ
    seats = { 東:"", 南:"", 西:"", 北:"" };

    // 画面切り替え
    roomListScreen.classList.add("hidden");
    playerSetupScreen.classList.remove("hidden");

    // プレイヤー選択用データをロード
    loadEntryPlayers();

    // リアルタイム監視
    db.ref(`rooms/${currentRoomId}/players`).on("value", snap => {
      const players = snap.val() || {};

      // DB に存在する方向だけを seats に反映（未選択は空のまま）
      Object.keys(seats).forEach(dir => seats[dir] = ""); // 一度全席リセット
      for (const [pid, p] of Object.entries(players)) {
        if (p.direction) seats[p.direction] = pid;
      }

      renderSeats();
      checkStart();
    });
  });
}

// =======================
// 参加者のプルダウン＆ラジオボタン描画
// =======================
async function renderSeats() {
  // roomInfoDiv 作成（1回だけ）
  let infoDiv = document.getElementById("roomInfoDiv");
  if (!infoDiv) {
    infoDiv = document.createElement("div");
    infoDiv.id = "roomInfoDiv";
    infoDiv.style.marginBottom = "8px";
    seatArea.appendChild(infoDiv);
  }

  // ルームの gameConfig と players をまとめて取得
  const [configSnap, playersSnap] = await Promise.all([
    db.ref(`rooms/${currentRoomId}/gameConfig`).once("value"),
    db.ref(`rooms/${currentRoomId}/players`).once("value")
  ]);

  const gameConfig = configSnap.val() || {};
  const playersData = playersSnap.val() || {};

  // ルーム情報更新
  infoDiv.innerHTML = `
    <div>ルール：${RULES[gameConfig.rule] || gameConfig.rule}</div>
    <div>原点：${gameConfig.startPoint ?? "-"}</div>
    <div>返し点：${gameConfig.returnPoint ?? "-"}</div>
  `;

  // seatArea から既存プルダウン削除
  const existingDivs = Array.from(seatArea.children).filter(d => d.id !== "roomInfoDiv");
  existingDivs.forEach(d => seatArea.removeChild(d));

  const usedPlayerIds = new Set(Object.values(seats).filter(pid => pid));

  for (const dir of Object.keys(seats)) {
    const container = document.createElement("div");
    container.style.display = "flex";
    container.style.alignItems = "center";
    container.style.marginBottom = "4px";

    const label = document.createElement("label");
    label.textContent = dir;
    label.style.marginRight = "8px";
    container.appendChild(label);

    const select = document.createElement("select");

    const defaultOpt = document.createElement("option");
    defaultOpt.value = "";
    defaultOpt.textContent = "未選択";
    select.appendChild(defaultOpt);

    const selectedCount = Object.values(seats).filter(v => v).length;
    const needCount = (currentRule === "3") ? 3 : 4;

    // この席が未選択で、すでに必要人数が揃っているなら disabled
    if (!seats[dir] && selectedCount >= needCount) {
      select.disabled = true;
    }

    for (const [id, p] of Object.entries(entryPlayers)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name;

      // 他の席にいるプレイヤーは選択不可
      if (usedPlayerIds.has(id) && seats[dir] !== id) {
        opt.disabled = true;
        opt.style.color = "#999";
      }

      // すでにその席にいる場合は選択状態
      if (seats[dir] === id) opt.selected = true;

      select.appendChild(opt);
    }

    select.onchange = async e => {
      const newPlayerId = e.target.value;
      const oldPlayerId = seats[dir];

      // 前のプレイヤーを削除
      if (oldPlayerId && oldPlayerId !== newPlayerId) {
        await db.ref(`rooms/${currentRoomId}/players/${oldPlayerId}`).remove();
      }

      seats[dir] = newPlayerId;

      if (newPlayerId) {
        const startPointSnap = await db.ref(`rooms/${currentRoomId}/gameConfig/startPoint`).once("value");
        const startPoint = startPointSnap.val();

        await db.ref(`rooms/${currentRoomId}/players/${newPlayerId}`).set({
          direction: dir,
          status: "waiting",
          point: startPoint,
          score: null,
          yakitoriFlg: true
        });

        currentGameInfo.playerId = newPlayerId;
        currentGameInfo.direction = dir;
        currentGameInfo.status = "waiting";
      } else {
        currentGameInfo.playerId = null;
        currentGameInfo.direction = null;
        currentGameInfo.status = null;
      }

      checkStart();
      saveAppState("playerSetupScreen");
    };

    container.appendChild(select);
    seatArea.appendChild(container);
  }
}


function loadEntryPlayers() {
  db.ref("systemConfig/entryPlayers").once("value").then(snap => {
    entryPlayers = snap.val() || {};
    renderSeats();
  });
}

let selectedSeat = "";

// 対局開始ボタン制御
function checkStart() {
  const count = Object.values(seats).filter(v=>v).length;
  const need = currentRule==="3" ? 3 : 4;
  startBtn.disabled = count !== need;
}


// ================= プレイヤー追加 =================
function openAddPlayer() {
  playerSetupScreen.classList.add("hidden");
  addPlayerScreen.classList.remove("hidden");
  saveAppState("addPlayerScreen");
}

function addPlayer() {
  const name = newPlayerName.value.trim();
  if (!name) return;

  const id = "p" + Date.now();
  db.ref(`systemConfig/entryPlayers/${id}`).set({ name }).then(() => {
    newPlayerName.value = "";
    backToPlayerSetup();
  });
}


// ===============================
// プレイヤー選択用ボタン描画
// ===============================
async function renderPlayerSelect() {
  if (!currentRoomId) return;
  playerSetupScreen.classList.add("hidden");
  playerSelectScreen.classList.remove("hidden");
  saveAppState("playerSelectScreen");

  const [playersSnap, entrySnap] = await Promise.all([
    db.ref(`rooms/${currentRoomId}/players`).once("value"),
    db.ref(`systemConfig/entryPlayers`).once("value")
  ]);

  const players = playersSnap.val() || {};
  const entryPlayers = entrySnap.val() || {};
  const directions = { 北:"player-north", 東:"player-east", 南:"player-south", 西:"player-west" };

  // direction -> playerId を1回で作る
  const dirToPid = {};
  for (const [pid, p] of Object.entries(players)) {
    if (p?.direction) dirToPid[p.direction] = pid;
  }

  for (const [dir, divId] of Object.entries(directions)) {
    const container = document.getElementById(divId);
    if (!container) continue;

    container.innerHTML = "";

    const playerId = dirToPid[dir];
    if (!playerId) {
      container.textContent = "未割当";
      continue;
    }

    const name = entryPlayers[playerId]?.name ?? "不明";

    const btn = document.createElement("button");
    btn.textContent = name;

    btn.onclick = () => selectPlayer(playerId, dir);
    container.appendChild(btn);
  }
}


// ===============================
// ボタン選択時の処理
// ===============================
async function selectPlayer(playerId, direction) {
  currentGameInfo.playerId = playerId;
  currentGameInfo.direction = direction;
  currentGameInfo.status = "playing";

  // 自分を playing に
  await db.ref(`rooms/${currentRoomId}/players/${playerId}/status`).set("playing");

  // ★ルーム状態を waiting → playing に（多重更新防止）
  const roomStatusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  await roomStatusRef.transaction(cur => {
    if (cur === "waiting") return "playing";
    return; // それ以外は変更なし
  });

  openGameScreen();
}



// ===============================
// 対局中 画面用（一時状態）
// ===============================
let gameStateUnsub = null;

let selectedRecipient = null; // 'N'|'W'|'S'
let sendAmountValue = 0;

// 方向の回転：自分がどのdirectionでも、画面上の N/W/S に相対配置する
// 例：自分が東なら N=北 W=西 S=南（画像仕様の例と一致）
const DIRS = ["東","南","西","北"];
function toRelative(selfDir, otherDir) {
  const si = DIRS.indexOf(selfDir);
  const oi = DIRS.indexOf(otherDir);
  if (si < 0 || oi < 0) return null;

  const diff = (oi - si + 4) % 4;

  // 自分を下固定：上=対面、右=次席、左=前席
  if (diff === 1) return "S"; // 右
  if (diff === 2) return "N"; // 上(対面)
  if (diff === 3) return "W"; // 左
  return null; // diff===0 は自分
}

function setText(id, text){ const el=document.getElementById(id); if(el) el.textContent = text; }

function setDiff(elId, diff){
  const el = document.getElementById(elId);
  if (!el) return;
  const v = Number(diff) || 0;
  el.textContent = (v >= 0 ? `+${v}` : `${v}`);
  el.classList.toggle("negative", v < 0);
}

// ===============================
// 対局画面を開く（呼び出し元は selectPlayer() など）
// ===============================
function openGameScreen() {
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  playerSetupScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  playerSelectScreen?.classList.add("hidden"); // ←戻す
  gameScreen.classList.remove("hidden");

  selectedRecipient = null;
  sendAmountValue = 0;
  setText("sendToName", "-");
  setText("sendAmount", "0");

  if (gameStateUnsub) gameStateUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);
    renderGameUI(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  gameStateUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
  subscribeRoomStatus();
}

let statusUnsub = null;

function subscribeRoomStatus() {
  if (!currentRoomId) return;

  const ref = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  if (statusUnsub) statusUnsub();

  const handler = (snap) => {
    const st = snap.val();
    if (st === "calculating") {
      openCalculatingScreen();
    }
    if (st === "end") {
      openEndScreen();
    }
  };

  ref.on("value", handler);
  statusUnsub = () => ref.off("value", handler);
}


// ===============================
// 画面描画（001〜012 など）
// ===============================
function renderGameUI(players, gameConfig, entryPlayers){
  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return; // まだDBにいない等

  // 001 自分の名前
  setText("myName", entryPlayers[myPid]?.name ?? "不明");

  // 012 自分のpoint（大きく）
  const myPoint = Number(my.point ?? 0);
  setText("myPoint", myPoint);

  // 002 リーチ棒本数
  setText("riichiCount", Number(gameConfig.riichiStickCount ?? 0));

  // 相手枠を初期化
  const slots = { N:null, W:null, S:null };
  for (const [pid, p] of Object.entries(players)){
    if (!p?.direction) continue;
    if (pid === myPid) continue;
    const rel = toRelative(my.direction, p.direction);
    if (rel) slots[rel] = { pid, p };
  }

  // N/W/S へ反映（003〜011）
  // 北枠
  renderOpponentSlot("N", slots.N, entryPlayers, myPoint);
  // 西枠
  renderOpponentSlot("W", slots.W, entryPlayers, myPoint);
  // 南枠
  renderOpponentSlot("S", slots.S, entryPlayers, myPoint);
}

function renderOpponentSlot(rel, slot, entryPlayers, myPoint){
  const nameId  = rel === "N" ? "nameN"  : rel === "W" ? "nameW"  : "nameS";
  const pointId = rel === "N" ? "pointN" : rel === "W" ? "pointW" : "pointS";
  const diffId  = rel === "N" ? "diffN"  : rel === "W" ? "diffW"  : "diffS";

  // ★タップエリア（座席全体）を取得
  const seatSel = rel === "N" ? ".gs-north" : rel === "W" ? ".gs-west" : ".gs-south";
  const seatEl = document.querySelector(seatSel);

  // まずクリック解除（毎回上書き）
  if (seatEl) {
    seatEl.onclick = null;
    seatEl.classList.remove("tapTarget");
  }

  if (!slot){
    setText(nameId, "-");
    setText(pointId, "-");
    setText(diffId, "-");
    return;
  }

  const { pid, p } = slot;
  const nm = entryPlayers[pid]?.name ?? "不明";
  const pt = Number(p.point ?? 0);

  setText(nameId, nm);
  setText(pointId, pt);
  setDiff(diffId, myPoint - pt);

  // ★座席全体タップで送り先選択 → ボトムシート表示
  if (seatEl) {
    seatEl.classList.add("tapTarget");
    seatEl.onclick = () => selectRecipient(rel);
  }
}



// ===============================
// 013 リーチ：リーチ棒+1 / 自分point-1000
// ===============================
async function onRiichiAdd(){
  const cfgRef = db.ref(`rooms/${currentRoomId}/gameConfig/riichiStickCount`);
  const myRef  = db.ref(`rooms/${currentRoomId}/players/${currentGameInfo.playerId}/point`);
  await cfgRef.transaction(v => (Number(v||0) + 1));
  await myRef.transaction(v => (Number(v||0) - 1000));
}

// ===============================
// 014 リーチ棒受取：自分point += 本数*1000 / リーチ棒0
// ===============================
async function onRiichiTake(){
  const cfgRef = db.ref(`rooms/${currentRoomId}/gameConfig/riichiStickCount`);
  const myRef  = db.ref(`rooms/${currentRoomId}/players/${currentGameInfo.playerId}/point`);

  const snap = await cfgRef.once("value");
  const cnt = Number(snap.val() || 0);
  if (cnt <= 0) return;

  await myRef.transaction(v => (Number(v||0) + cnt * 1000));
  await cfgRef.set(0);
}

// ===============================
// 019-021 送り先選択（常にアクティブ）
// ===============================
async function selectRecipient(rel){
  // rel: 'N'|'W'|'S'
  selectedRecipient = rel;
  sendAmountValue = 0;
  setText("sendAmount", "0");

  // 現在の相手を解決して 015 に表示
  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const eSnap = await db.ref(`systemConfig/entryPlayers`).once("value");
  const players = pSnap.val() || {};
  const entryPlayers = eSnap.val() || {};

  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return;

  let targetPid = null;
  for (const [pid, p] of Object.entries(players)){
    if (pid === myPid) continue;
    const r = toRelative(my.direction, p.direction);
    if (r === rel) { targetPid = pid; break; }
  }

  setText("sendToName", targetPid ? (entryPlayers[targetPid]?.name ?? "不明") : "-");
  openTransferSheet();
}

// ===============================
// 022-026 金額加算（015が出ている場合に有効、という仕様に近づける）
// ===============================
function addAmount(amount){
  if (!selectedRecipient) return; // 送り先未選択なら何もしない
  sendAmountValue += amount;
  setText("sendAmount", String(sendAmountValue));
}

// ===============================
// 017 取消：送り先/金額リセット
// ===============================
function cancelTransfer(){
  selectedRecipient = null;
  sendAmountValue = 0;
  setText("sendToName", "-");
  setText("sendAmount", "0");
  closeTransferSheet();
}


// ===============================
// 018 確定：自分→相手へ point 移動
// 015 の相手に 016 の点数を移動
// ===============================
async function confirmTransfer(){
  if (!selectedRecipient) return;
  if (sendAmountValue <= 0) return;

  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = pSnap.val() || {};
  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return;

  // 相手pid解決
  let targetPid = null;
  for (const [pid, p] of Object.entries(players)){
    if (pid === myPid) continue;
    const r = toRelative(my.direction, p.direction);
    if (r === selectedRecipient) { targetPid = pid; break; }
  }
  if (!targetPid) return;

  const myPointRef = db.ref(`rooms/${currentRoomId}/players/${myPid}/point`);
  const tgPointRef = db.ref(`rooms/${currentRoomId}/players/${targetPid}/point`);

  // 同時更新（transactionで安全寄りに）
  await myPointRef.transaction(v => Number(v||0) - sendAmountValue);
  await tgPointRef.transaction(v => Number(v||0) + sendAmountValue);

  cancelTransfer();
}

// リーチ棒表示
function renderRiichiSticks(count){
  const wrap = document.getElementById("riichiSticks");
  const num  = document.getElementById("riichiCount");
  if (!wrap || !num) return;

  const c = Number(count || 0);

  wrap.innerHTML = "";

  if (c <= 0){
    num.textContent = "0";
    return;
  }

  // 棒は常に1本だけ
  const d = document.createElement("div");
  d.className = "stick";
  wrap.appendChild(d);

  // ×N 表示
  num.textContent = `×${c}`;
}


// ボトムシートを開く
function openTransferSheet(){
  transferOverlay.classList.remove("hidden");
  transferSheet.classList.remove("hidden");
  // アニメ用クラスは次フレームで付ける（効く）
  requestAnimationFrame(() => transferSheet.classList.add("is-open"));
}

// ボトムシートを閉じる
function closeTransferSheet(){
  transferSheet.classList.remove("is-open");
  transferOverlay.classList.add("hidden");
  // transition後にhiddenへ（雑でもOKならsetTimeout）
  setTimeout(() => {
    transferSheet.classList.add("hidden");
  }, 230);
}


// ===============================
// 対局終了ボタン
// ===============================
async function endGame() {
  const myPid = currentGameInfo.playerId;
  if (!myPid) return;

  // 自分を calculating に
  await db.ref(`rooms/${currentRoomId}/players/${myPid}/status`).set("calculating");

  // ★反映後の players を取り直す
  const playersSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = playersSnap.val() || {};

  const calcCount = Object.values(players).filter(p => p?.status === "calculating").length;
  const need = (currentRule === "3") ? 3 : 4;

  if (calcCount >= need) {
    const statusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
    await statusRef.transaction(cur => {
      // end なら触らない
      if (cur === "end") return;
      // すでに calculating でも触らない
      if (cur === "calculating") return;
      // waiting/playing どちらでも calculating にする
      return "calculating";
    });
  }

  alert("対局終了を送信しました。");
}




let calcUnsub = null;

function openCalculatingScreen() {
  // 画面切替
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  playerSetupScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  playerSelectScreen?.classList.add("hidden");
  gameScreen?.classList.add("hidden");
  calculatingScreen.classList.remove("hidden");

  subscribeCalculating();
}

function subscribeCalculating() {
  if (!currentRoomId) return;

  if (calcUnsub) calcUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);
    renderCalculatingUI(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
    checkAllEndAndClose(pSnap.val() || {}, cSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  calcUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
}


function resolvePosPids(players) {
  const myPid = currentGameInfo.playerId;
  const myDir = currentGameInfo.direction;
  const out = { ME: myPid, N: null, W: null, S: null };

  for (const [pid, p] of Object.entries(players)) {
    if (!p?.direction) continue;
    if (pid === myPid) continue;

    const rel = toRelative(myDir, p.direction); // 'N'|'W'|'S' を返すやつ
    if (rel) out[rel] = pid;
  }
  return out;
}


function calcScoreUnits(point, returnPoint) {
  return Math.ceil((Number(point || 0) - Number(returnPoint || 0)) / 1000);
}


function renderCalculatingUI(players, gameConfig, entryPlayers) {
  const pos = resolvePosPids(players);
  const returnPoint = Number(gameConfig.returnPoint || 0);

  // 4人分（ME/N/W/S）を配列化（存在しない席は除外）
  const list = ["ME","N","W","S"]
    .map(k => ({ k, pid: pos[k], p: pos[k] ? players[pos[k]] : null }))
    .filter(x => x.pid && x.p);

  // 名前表示（方角 + name）
  const nameOf = (pid) => entryPlayers[pid]?.name ?? "不明";
  const dirOf  = (pid) => players[pid]?.direction ?? "-";

  // 表示：005/006/007/008
  // ★縦並び（innerHTML）
  if (pos.N)  document.getElementById("calcTopName").innerHTML   = `<div>${dirOf(pos.N)}家</div><div>${nameOf(pos.N)}</div>`;
  if (pos.W)  document.getElementById("calcLeftName").innerHTML  = `<div>${dirOf(pos.W)}家</div><div>${nameOf(pos.W)}</div>`;
  if (pos.S)  document.getElementById("calcRightName").innerHTML = `<div>${dirOf(pos.S)}家</div><div>${nameOf(pos.S)}</div>`;
  if (pos.ME) document.getElementById("calcMyName").innerHTML    = `<div>${dirOf(pos.ME)}家</div><div>${nameOf(pos.ME)}</div>`;;

  // まず②の計算（全員分）
  const base = {};
  for (const x of list) {
    const u = calcScoreUnits(x.p.point, returnPoint);
    base[x.k] = u + (x.p.yakitoriFlg === true ? -10 : 0);
  }

  // トップ判定は point の最大
  let topK = null;
  let topPoint = -Infinity;
  for (const x of list) {
    const pt = Number(x.p.point || 0);
    if (pt > topPoint) { topPoint = pt; topK = x.k; }
  }

  // ①トップは「他人合計×-1」
  if (topK) {
    const othersSum = Object.entries(base)
      .filter(([k]) => k !== topK)
      .reduce((acc, [,v]) => acc + Number(v||0), 0);

    base[topK] = -1 * othersSum;
  }

  // 表示：009/010/011/012
  setText("calcTopScore",  pos.N  ? String(base["N"] ?? "-")  : "-");  // 010
  setText("calcLeftScore", pos.W  ? String(base["W"] ?? "-")  : "-");  // 009
  setText("calcRightScore",pos.S  ? String(base["S"] ?? "-")  : "-");  // 011
  setText("calcMyScore",   pos.ME ? String(base["ME"] ?? "-") : "-");  // 012

  // 001-004 ヤキトリボタン表示（trueなら「ヤキトリ」、falseなら空表示）
  setYakitoriButton("btnYakitoriTop",   pos.N,  players);
  setYakitoriButton("btnYakitoriLeft",  pos.W,  players);
  setYakitoriButton("btnYakitoriRight", pos.S,  players);
  setYakitoriButton("btnYakitoriMe",    pos.ME, players);

  // rooms/{roomId}/gameConfig/status == end の場合ボタン非活性
  const isRoomEnd = (gameConfig.status === "end");

  // player/{id}/status == "end" の人はヤキトリ操作不可（個別判定）
  const isPlayerEnd = (pid) => !!pid && players?.[pid]?.status === "end";

  // 集計中画面では「自分(ME)以外のヤキトリボタンは操作不可」
  const myPid = pos.ME;

  const yakitoriMap = [
    ["btnYakitoriTop",   pos.N],
    ["btnYakitoriLeft",  pos.W],
    ["btnYakitoriRight", pos.S],
    ["btnYakitoriMe",    pos.ME],
  ];

  for (const [btnId, pid] of yakitoriMap) {
    const b = document.getElementById(btnId);
    if (!b) continue;

    const isOther = !!pid && pid !== myPid; // 自分以外
    b.disabled = isRoomEnd || isPlayerEnd(pid) || isOther;
  }

  // 集計完了ボタンは部屋endで無効化
  const endBtn = document.getElementById("btnCalcEnd");
  if (endBtn) endBtn.disabled = isRoomEnd;

}

function computeScoresForRoom(players, gameConfig) {
  const returnPoint = Number(gameConfig.returnPoint || 0);

  // 参加者だけ抽出（directionがある人）
  const active = Object.entries(players || {})
    .filter(([pid, p]) => p?.direction) // 参加者のみ
    .map(([pid, p]) => ({ pid, p }));

  if (active.length === 0) return {};

  // ②：ceil((point-returnPoint)/1000) + (yakitoriFlg===true ? -10 : 0)
  const base = {};
  for (const { pid, p } of active) {
    const u = Math.ceil((Number(p.point || 0) - returnPoint) / 1000);
    base[pid] = u + (p.yakitoriFlg === true ? -10 : 0);
  }

  // ①：point最大の人をトップとし、他人の合計×-1
  let topPid = active[0].pid;
  let topPoint = Number(active[0].p.point || 0);
  for (const { pid, p } of active) {
    const pt = Number(p.point || 0);
    if (pt > topPoint) { topPoint = pt; topPid = pid; }
  }

  const othersSum = Object.entries(base)
    .filter(([pid]) => pid !== topPid)
    .reduce((acc, [,v]) => acc + Number(v || 0), 0);

  base[topPid] = -1 * othersSum;

  return base; // { pid: score, ... }
}

function setYakitoriButton(btnId, pid, players) {
  const btn = document.getElementById(btnId);
  if (!btn) return;
  if (!pid || !players[pid]) { btn.textContent = "-"; btn.disabled = true; return; }

  const flg = players[pid].yakitoriFlg === true;
  btn.textContent = flg ? "ヤキトリ" : "　　　　"; // 仕様どおり
  btn.disabled = false;
}


async function toggleYakitoriByPos(which) {
  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = pSnap.val() || {};
  const pos = resolvePosPids(players);

  const pid = (which === "ME") ? pos.ME : pos[which];
  if (!pid) return;

  const ref = db.ref(`rooms/${currentRoomId}/players/${pid}/yakitoriFlg`);
  const cur = players[pid]?.yakitoriFlg === true;
  await ref.set(!cur);
}

async function finishCalculating() {
  const pid = currentGameInfo.playerId;
  if (!pid) return;
  await db.ref(`rooms/${currentRoomId}/players/${pid}/status`).set("end");
  alert("集計完了を送信しました。");
}


async function checkAllEndAndClose(players, gameConfig) {
  if (!currentRoomId) return;

  // すでに終了確定済みなら何もしない（多重実行防止）
  if (gameConfig.status === "end") return;

  const endCount = Object.values(players || {}).filter(p => p?.status === "end").length;
  const need = (currentRule === "3") ? 3 : 4;
  if (endCount < need) return;

  // ★最後の人が複数同時に入ることがあるので status を先に確認してガード
  const statusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  const stSnap = await statusRef.once("value");
  const st = stSnap.val();
  if (st === "end") return;

  // score計算（表示と同じ）
  const scores = computeScoresForRoom(players, gameConfig);

  // players/{pid}/score に一括反映（multi-location update）
  const updates = {};
  for (const [pid, sc] of Object.entries(scores)) {
    updates[`rooms/${currentRoomId}/players/${pid}/score`] = sc;
  }

  // ついでに status を end にする（集計完了の確定）
  updates[`rooms/${currentRoomId}/gameConfig/status`] = "end";

  await db.ref().update(updates);

  alert("全員の集計完了が揃いました。スコアを保存しました（対局終了画面は未作成）");
  openEndScreen();
}



// ===============================
// 対局終了画面：リアルタイム購読
// ===============================
let endUnsub = null;

function openEndScreen() {
  // 画面切替
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  playerSetupScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  playerSelectScreen?.classList.add("hidden");
  gameScreen?.classList.add("hidden");
  calculatingScreen?.classList.add("hidden");
  endScreen.classList.remove("hidden");

  subscribeEndScreen();
}

function subscribeEndScreen() {
  if (!currentRoomId) return;

  if (endUnsub) endUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);

    renderEndScreen(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  endUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
}

function renderEndScreen(players, gameConfig, entryPlayers) {
  // 001 ルール表示
  const ruleMap = { "3":"3麻", "3r4":"3麻4人回", "4":"4麻" };
  const ruleText = ruleMap[gameConfig.rule] || gameConfig.rule || "-";
  const ruleBtn = document.getElementById("endRuleBtn");
  if (ruleBtn) ruleBtn.textContent = ruleText;

  // 002,003 原点/返し点
  setText("endStartPoint", gameConfig.startPoint ?? "-");
  setText("endReturnPoint", gameConfig.returnPoint ?? "-");

  // 参加者（directionがある人）だけを対象に、score降順で並べる
  const list = Object.entries(players || {})
    .filter(([pid, p]) => p?.direction) // 参加者
    .map(([pid, p]) => ({
      pid,
      name: entryPlayers?.[pid]?.name ?? "不明",
      score: (p.score ?? null),
      yakitori: (p.yakitoriFlg === true),
      point: Number(p.point ?? 0),
    }))
    // scoreが未計算（null）の人は最後に回す
    .sort((a, b) => {
      const as = (a.score === null || a.score === undefined) ? -Infinity : Number(a.score);
      const bs = (b.score === null || b.score === undefined) ? -Infinity : Number(b.score);
      if (bs !== as) return bs - as;
      // 同点なら point で安定化（任意）
      return (b.point - a.point);
    });

  // 3麻なら4位枠を隠す（見た目の要望がある場合）
  const is3 = (gameConfig.rule === "3");
  const rank4Box = document.getElementById("rank4Box");
  if (rank4Box) rank4Box.style.display = is3 ? "none" : "block";

  // 004-011, 012-015 埋める
  const ranks = [
    { nameId:"rank1Name", scoreId:"rank1Score", yId:"rank1Yakitori" },
    { nameId:"rank2Name", scoreId:"rank2Score", yId:"rank2Yakitori" },
    { nameId:"rank3Name", scoreId:"rank3Score", yId:"rank3Yakitori" },
    { nameId:"rank4Name", scoreId:"rank4Score", yId:"rank4Yakitori" },
  ];

  const showCount = is3 ? 3 : 4;

  for (let i = 0; i < ranks.length; i++) {
    const r = ranks[i];
    const row = list[i];

    if (i >= showCount) {
      // 3麻の4位は非表示想定だが、念のためクリア
      setText(r.nameId, "-");
      setText(r.scoreId, "-");
      setText(r.yId, "");
      continue;
    }

    if (!row) {
      setText(r.nameId, "-");
      setText(r.scoreId, "-");
      setText(r.yId, "");
      continue;
    }

    setText(r.nameId, row.name);                 // 004-007
    setText(r.scoreId, row.score ?? "-");        // 008-011
    setText(r.yId, row.yakitori ? "ヤキトリ" : ""); // 012-015
  }
}

// 画面離脱時は購読解除
function stopAllSubscriptions() {
  if (roomsUnsub) roomsUnsub();
  if (gameStateUnsub) gameStateUnsub();
  if (calcUnsub) calcUnsub();
  if (endUnsub) endUnsub();
}


// ------------------- DB削除 -------------------
function deleteRoom(roomId) {
  if(!confirm("このルームを削除しますか？")) return;
  db.ref(`rooms/${roomId}/gameConfig/status`).set("delete");
}



// ================= 戻る =================
function backToPlayerSetup() {
  addPlayerScreen.classList.add("hidden");

  if (addPlayerReturnTo === "playerConfig") {
    openPlayerConfigScreen("");
    return;
  }
  if (addPlayerReturnTo === "roomList") {
    showRoomListScreen();
    return;
  }

  playerSetupScreen.classList.remove("hidden");
  loadEntryPlayers();
}


// ルーム一覧画面への遷移
function backToRoomList() {
  try {
    // 先に購読解除（画面切替前に安全に）
    if (calcUnsub) { calcUnsub(); calcUnsub = null; }
    if (statusUnsub) { statusUnsub(); statusUnsub = null; }
    if (gameStateUnsub) { gameStateUnsub(); gameStateUnsub = null; }
    if (endUnsub) { endUnsub(); endUnsub = null; }
    if (roomsUnsub) { roomsUnsub(); roomsUnsub = null; }

    hideAllScreens();

    // ★保存するscreen名は実在するIDに合わせる
    saveAppState("roomListScreen");

    roomListScreen.classList.remove("hidden");

    // 一覧描画
    subscribeRooms(); // これで renderRoomList が走る
  } catch (e) {
    console.error("backToRoomList error:", e);

    // ★最悪でも roomList は出す（真っ白回避）
    hideAllScreens();
    roomListScreen.classList.remove("hidden");
    alert("画面遷移でエラー。コンソールの backToRoomList error を確認してください。");
  }
}


// 画面縦横調整用
function applyOrientationClass(){
  const isLandscape = window.matchMedia("(orientation: landscape)").matches;
  document.documentElement.classList.toggle("is-landscape", isLandscape);
  document.documentElement.classList.toggle("is-portrait", !isLandscape);
}

window.addEventListener("load", applyOrientationClass);
window.addEventListener("resize", applyOrientationClass);
window.addEventListener("orientationchange", applyOrientationClass);


// sessionStorageに必要な情報格納
function saveAppState(screen) {
  sessionStorage.setItem(APP_STATE_KEY, JSON.stringify({
    loggedIn: true,
    screen,
    roomId: currentRoomId ?? null,
    currentGameInfo: currentGameInfo ?? {},
    myDeviceId: myDeviceId ?? null,
    myPlayerId: myPlayerId ?? null
  }));
}

window.addEventListener("load", async () => {

  // Service Worker 登録（そのまま）
  if ("serviceWorker" in navigator) {
    try {
      await navigator.serviceWorker.register("/sw.js");
      console.log("SW registered");
    } catch (e) {
      console.log("SW register failed:", e);
    }
  }

  const stateStr = sessionStorage.getItem(APP_STATE_KEY);
  if (!stateStr) return;

  let state;
  try { state = JSON.parse(stateStr); }
  catch {
    sessionStorage.removeItem(APP_STATE_KEY);
    return;
  }

  if (!state.loggedIn) return;

  // ★ログイン済みなら、deviceMap判定へ
  await bootstrapAfterLogin();
});


function setRealVH(){
  const vh = window.visualViewport
    ? window.visualViewport.height * 0.01
    : window.innerHeight * 0.01;

  document.documentElement.style.setProperty("--vh", `${vh}px`);
}

setRealVH();

window.addEventListener("resize", setRealVH);
window.visualViewport?.addEventListener("resize", setRealVH);


</script>
</body>
</html>

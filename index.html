<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<link rel="manifest" href="/manifest.json">
<link rel="stylesheet" href="style.css">

<meta name="theme-color" content="#CFEEC0">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">

<script src="firebaseConfig.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<style>
.hidden { display:none; }
.room { border:1px solid #ccc; margin:6px 0; padding:6px; }
select { margin-left:6px; }
</style>
</head>

<body>

<!-- ========================================= -->
<!-- ãƒ­ã‚°ã‚¤ãƒ³ -->
<!-- ========================================= -->
<div id="loginScreen">
  <input id="loginPass" placeholder="ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰">
  <button onclick="login()">ãƒ­ã‚°ã‚¤ãƒ³</button>
</div>

<!-- ========================================= -->
<!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šï¼ˆæ–°è¦ï¼‰ -->
<!-- ========================================= -->
<div id="playerConfigScreen" class="hidden">
  <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</h2>

  <!-- 001: ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ -->
  <div style="margin:12px 0;">
    <label>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼š</label>
    <select id="playerConfigSelect"></select>
  </div>

  <!-- 002: è¨­å®šå®Œäº† -->
  <button id="btnPlayerConfigDone" onclick="completePlayerConfig()">è¨­å®šå®Œäº†</button>

  <div style="height:24px;"></div>

  <!-- 004: ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸æˆ»ã‚‹ -->
  <div style="margin-top:12px;">
    <button onclick="goRoomList()">ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸æˆ»ã‚‹</button>
  </div>

  <div id="playerConfigMsg" style="margin-top:10px; color:#b00;"></div>
</div>


<!-- ========================================= -->
<!-- ãƒ«ãƒ¼ãƒ ä¸€è¦§ -->
<!-- ========================================= -->
<div id="roomListScreen" class="hidden">

  <!-- å›ºå®šï¼ˆãƒ«ãƒ¼ãƒ ä¸€è¦§ã§ã®ã¿è¡¨ç¤ºï¼‰ -->
  <div class="roomListTop">
    <h2>ãƒ«ãƒ¼ãƒ ä¸€è¦§</h2>
    <div id="myPlayerLabel" style="font-weight:700;"></div>

    <div class="roomListButtons">
      <button onclick="openRoomCreateScreen()">ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
      <button onclick="openPlayerConfigScreen()">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š</button>
      <button onclick="openAddPlayerFromRoomList()">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ </button>
    </div>

    <div id="roomListTableHeader"></div>
  </div>

  <!-- ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼ˆãƒ«ãƒ¼ãƒ ä¸€è¦§ã§ã®ã¿è¡¨ç¤ºï¼‰ -->
  <div id="roomList" class="roomListScroll"></div>

</div>

<!-- ========================================= -->
<!-- ãƒ«ãƒ¼ãƒ ä½œæˆï¼ˆæ–°è¦ï¼‰ -->
<!-- ========================================= -->
<div id="roomCreateScreen" class="hidden">
  <h2>ãƒ«ãƒ¼ãƒ ä½œæˆ</h2>

  <div style="margin:10px 0;">
    <div style="margin-bottom:8px;">ãƒ«ãƒ¼ãƒ«ï¼š</div>
    <label><input type="radio" name="create_rule" value="3" checked>3éº»</label>
    <label style="margin-left:10px;"><input type="radio" name="create_rule" value="3r4">3éº»4äººå›ã—</label>
    <label style="margin-left:10px;"><input type="radio" name="create_rule" value="4">4éº»</label>
  </div>

  <div style="margin:10px 0;">
    <label>åŸç‚¹ï¼š</label>
    <input type="number" id="createStartPoint" step="5000" value="45000" style="width:120px;">
  </div>

  <div style="margin:10px 0;">
    <label>è¿”ã—ç‚¹ï¼š</label>
    <input type="number" id="createReturnPoint" step="5000" value="50000" style="width:120px;">
  </div>

  <div style="margin:14px 0;">
    <div style="margin-bottom:8px;">å¸­é †</div>

    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">æ±ï¼š</div>
      <select id="createSeatE"></select>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">å—ï¼š</div>
      <select id="createSeatS"></select>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">è¥¿ï¼š</div>
      <select id="createSeatW"></select>
    </div>
    <div style="display:flex; align-items:center; gap:10px; margin:6px 0;">
      <div style="width:40px;">åŒ—ï¼š</div>
      <select id="createSeatN"></select>
    </div>
  </div>

  <div style="display:flex; gap:10px; margin-top:14px;">
    <button id="btnCreateRoomDo" onclick="createRoomFromCreateScreen()">ãƒ«ãƒ¼ãƒ ä½œæˆ</button> <!-- 008 -->
    <button onclick="backToRoomList()">æˆ»ã‚‹</button>
  </div>

  <div id="roomCreateMsg" style="margin-top:10px; color:#b00;"></div>
</div>


<!-- ========================================= -->
<!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ  -->
<!-- ========================================= -->
<div id="addPlayerScreen" class="hidden">
  <h2>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ </h2>
  <input id="newPlayerName" placeholder="åå‰">
  <button onclick="addPlayer()">ç™»éŒ²</button>
  <button onclick="backToPlayerSetup()">æˆ»ã‚‹</button>
</div>


<!-- ========================================= -->
<!-- å¯¾å±€ç”»é¢ -->
<!-- ========================================= -->
<div id="gameScreen" class="hidden">
  <h2 class="gs-title">å¯¾å±€ä¸­</h2>
  <!-- ãƒªãƒ¼ãƒæ£’è¡¨ç¤ºï¼ˆå·¦ä¸Šï¼‰ -->
  <div id="riichiHUD" class="riichiHUD" aria-label="ãƒªãƒ¼ãƒæ£’">
    <span class="riichiStick" aria-hidden="true"></span>
    <span class="riichiTimes">Ã—<span id="riichiCount">0</span></span>
  </div>
  <div class="gs-layout">
    <!-- =========================
         å·¦ï¼šå“ï¼ˆç‚¹æ•°è¡¨ç¤ºï¼‰
    ========================== -->
    <section class="gs-tableWrap">
      <div id="gameTable" class="gs-table">
        <!-- åŒ—(ç›¸æ‰‹) -->
        <div class="gs-seat gs-north">
          <div class="gs-name" id="nameN">-</div>
          <div class="gs-point" id="pointN">-</div>
          <div class="gs-diff" id="diffN">-</div>
          <img class="yakitoriImg" id="yakitoriN" src="image/yakitori_on.png" alt="">
        </div>

        <!-- è¥¿(ç›¸æ‰‹) -->
        <div class="gs-seat gs-west">
          <div class="gs-name" id="nameW">-</div>
          <div class="gs-point" id="pointW">-</div>
          <div class="gs-diff" id="diffW">-</div>
          <img class="yakitoriImg" id="yakitoriW" src="image/yakitori_on.png" alt="">
        </div>

        <!-- æ±(è‡ªåˆ†) -->
        <div class="gs-seat gs-self">
          <div class="gs-selfName" id="myName">-</div>
          <div class="gs-selfPoint" id="myPoint">-</div>
          <img class="yakitoriImg" id="yakitoriME" src="image/yakitori_on.png" alt="">
        </div>

        <!-- å—(ç›¸æ‰‹) -->
        <div class="gs-seat gs-south">
          <div class="gs-name" id="nameS">-</div>
          <div class="gs-point" id="pointS">-</div>
          <div class="gs-diff" id="diffS">-</div>
          <img class="yakitoriImg" id="yakitoriS" src="image/yakitori_on.png" alt="">
        </div>
      </div>
    </section>
  </div>

  <!-- =========================
        ä¸‹ï¼šæ“ä½œãƒ‘ãƒãƒ«
  ========================== -->
  <aside class="gs-panel">
    <!-- ãƒªãƒ¼ãƒç³» -->
    <div class="gs-row">
      <button class="gs-btn gs-btnWide" id="btnRiichiAdd" onclick="onRiichiAdd()">ãƒªãƒ¼ãƒ</button>
      <button class="gs-btn" id="btnRiichiTake" onclick="onRiichiTake()">å—å–</button>
      <button class="gs-btn" id="btnGyaku" onclick="openGyakuSheet()">é€†è»¢æ¡ä»¶</button>
      <button class="gs-btn" id="btnHistory" onclick="openHistorySheet()">å±¥æ­´</button>
    </div>
    <div class="gs-row">
    <!-- å¯¾å±€çµ‚äº† -->
      <button class="gs-btn gs-btnDanger" id="btnEndGame" onclick="endGame()">å¯¾å±€çµ‚äº†</button>
      <button class="gs-btn" onclick="backToRoomList()">ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸æˆ»ã‚‹</button>
    </div>
  </aside>
</div>


<!-- =========================
     æ”¯æ‰•ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆï¼ˆä¸‹ã‹ã‚‰ã›ã‚Šå‡ºã—ï¼‰
========================= -->
<div id="transferOverlay" class="ts-overlay hidden" onclick="closeTransferSheet()"></div>

<div id="transferSheet" class="ts-sheet hidden" role="dialog" aria-modal="true">
  <div class="ts-handle"></div>

  <div class="ts-header">
    <div class="ts-title">æ”¯æ‰•</div>
    <button class="ts-close" onclick="closeTransferSheet()">âœ•</button>
  </div>

  <!-- æ”¯æ‰•çŠ¶æ³ï¼ˆå…ƒã®èµ¤æ ã®ä¸Šéƒ¨ï¼‰ -->
  <div class="gs-card">
    <div class="gs-cardRow">
      <div class="gs-cardLabel">æ”¯æ‰•å…ˆï¼š</div>
      <div class="gs-cardValue"><span id="sendToName">-</span></div>
    </div>
    <div class="gs-cardRow">
      <div class="gs-cardLabel">æ”¯æ‰•ç‚¹æ•°ï¼š</div>
      <div class="gs-cardValue"><span id="sendAmount">0</span></div>
    </div>
  </div>

  <!-- åŠ ç®—ãƒœã‚¿ãƒ³ -->
  <div class="gs-amountGrid">
    <button class="gs-btn" onclick="addAmount(10000)">10000</button>
    <button class="gs-btn" onclick="addAmount(1000)">1000</button>
    <button class="gs-btn" onclick="addAmount(100)">100</button>
    <button class="gs-btn" onclick="addAmount(5000)">5000</button>
    <button class="gs-btn" onclick="addAmount(500)">500</button>
    <button class="gs-btn gs-btnSub" onclick="cancelAmountValue()">ã‚¯ãƒªã‚¢</button>
  </div>

  <!-- ç¢ºå®š/å–æ¶ˆ -->
  <div class="gs-row">
    <button class="gs-btn gs-btnPrimary" id="btnConfirm" onclick="confirmTransfer()">ç¢ºå®š</button>
    <button class="gs-btn" id="btnCancel" onclick="cancelTransfer()">å–æ¶ˆ</button>
  </div>
</div>

<!-- =========================
     å—å–ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ï¼ˆpaymentã®ã¿ï¼‰
========================= -->
<div id="receiveOverlay" class="ts-overlay hidden"></div>

<div id="receiveSheet" class="ts-sheet hidden" role="dialog" aria-modal="true">
  <div class="ts-handle"></div>

  <div class="ts-header">
    <div class="ts-title">æ”¯æ‰•æƒ…å ±</div>
    <button class="ts-close" onclick="closeReceiveSheet()">Ã—</button>
  </div>

  <div class="gs-card">
    <div class="gs-cardRow">
      <div class="gs-cardLabel">æ”¯æ‰•ï¼š</div>
      <div class="gs-cardValue">
        <span id="recvFromName">-</span> â†’ <span id="recvToName">-</span>
      </div>
    </div>

    <div class="gs-cardRow">
      <div class="gs-cardLabel">æ”¯æ‰•ç‚¹ï¼š</div>
      <div class="gs-cardValue"><span id="recvPoint">-</span></div>
    </div>

    <div class="gs-cardRow">
      <div class="gs-cardLabel">å—å–å‰ï¼š</div>
      <div class="gs-cardValue"><span id="recvToBefore">-</span></div>
    </div>

    <div class="gs-cardRow">
      <div class="gs-cardLabel">å—å–å¾Œï¼š</div>
      <div class="gs-cardValue"><span id="recvToAfter">-</span></div>
    </div>
  </div>

  <div class="gs-row">
    <button class="gs-btn gs-btnPrimary" id="btnRecvCheck" onclick="checkReceive()">ç¢ºèª</button>
  </div>
</div>

<!-- =========================
     é€†è»¢æ¡ä»¶ï¼ˆãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆï¼‰
========================= -->
<div id="gyakuOverlay" class="ts-overlay hidden" onclick="closeGyakuSheet()"></div>

<div id="gyakuSheet" class="ts-sheet hidden" role="dialog" aria-modal="true">
  <div class="ts-handle"></div>

  <div class="ts-header">
    <div class="ts-title">é€†è»¢æ¡ä»¶</div>
    <button class="ts-close" onclick="closeGyakuSheet()">âœ•</button>
  </div>

  <!-- â˜…ã“ã“ã‹ã‚‰ä¸‹ã ã‘ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã•ã›ã‚‹ -->
  <div class="ts-body" id="gyakuBody">

    <!-- 023: è¦ª/å­ï¼ˆè‡ªåˆ†ã®ç«‹å ´ï¼‰ -->
    <div class="gs-card">
      <div style="font-weight:900; margin-bottom:6px;">è‡ªåˆ†ã®ç«‹å ´</div>
      <label style="margin-left:12px;"><input type="radio" name="gySelfRole" value="child">å­</label>
      <label><input type="radio" name="gySelfRole" value="parent">è¦ª</label>
      <div style="margin-top:6px; font-size:12px; opacity:.8;">
        åˆ‡æ›¿ã§é€†è»¢æ¡ä»¶ã‚’å†è¨ˆç®—ã—ã¾ã™
      </div>
      <div class="gs-cardRow">
        <div class="gs-cardLabel">ãƒˆãƒƒãƒ—ï¼š</div>
        <div class="gs-cardValue">
          <span id="gyName">-</span>
        </div>
      </div>
      <div class="gs-cardRow">
        <div class="gs-cardLabel">è‡ªåˆ†ï¼š</div>
        <div class="gs-cardValue">
          <span id="gyMyName">-</span>
        </div>
      </div>
      <div class="gs-cardRow">
        <div class="gs-cardLabel">ç‚¹å·®ï¼š</div>
        <div class="gs-cardValue">
          <span id="gyDiff">-</span>
        </div>
      </div>
    </div>

    <!-- ç›´æ’ƒï¼ˆãƒ­ãƒ³ï¼‰ -->
    <div class="gs-card">
      <div style="font-weight:900; margin-bottom:6px;">ç›´æ’ƒã®å ´åˆ</div>
      <div class="gy-subCard">
   
        <div style="font-weight:800; margin-bottom:6px;">åŒå“</div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">æ¡ä»¶ï¼š</div>
          <div class="gs-cardValue"><span id="gyRonNeed">-</span></div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">è‡ªåˆ†ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonMeBefore">-</span> â†’ <span id="gyRonMeAfter">-</span>
            <span id="gyRonMeDelta" class="gy-delta">ï¼ˆ+0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">ãƒˆãƒƒãƒ—ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonTopBefore">-</span> â†’ <span id="gyRonTopAfter">-</span>
            <span id="gyRonTopDelta" class="gy-delta negative">ï¼ˆ-0ï¼‰</span>
          </div>
        </div>
      </div>
   
      <!-- â˜…3éº»4äººå›ã—ï¼šæŠœã‘ç•ªï¼ˆãƒ­ãƒ³ï¼‰ -->
      <div id="gyRonNuke" class="gy-subCard hidden" style="margin-top:10px;">
        <div style="font-weight:800; margin-bottom:6px;">ç›¸æ‰‹ãŒæŠœã‘ç•ª</div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">æ¡ä»¶ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonNeed_nuke">-</span>
            <span style="font-size:12px; opacity:.7;"></span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">è‡ªåˆ†ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonMeBefore_nuke">-</span> â†’ <span id="gyRonMeAfter_nuke">-</span>
            <span id="gyRonMeDelta_nuke" class="gy-delta">ï¼ˆ+0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel"><span id="gyRonTopName">TOP</span>ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonTopBefore_nuke">-</span> â†’ <span id="gyRonTopAfter_nuke">-</span>
            <span id="gyRonTopDelta_nuke" class="gy-delta">ï¼ˆÂ±0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel"><span id="gyRonOther1Name">ãã®ä»–â‘ </span>ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonOther1Before">-</span> â†’ <span id="gyRonOther1After">-</span>
            <span id="gyRonOther1Delta" class="gy-delta negative">ï¼ˆ-0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel"><span id="gyRonOther2Name">ãã®ä»–â‘¡</span>ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyRonOther2Before">-</span> â†’ <span id="gyRonOther2After">-</span>
            <span id="gyRonOther2Delta" class="gy-delta negative">ï¼ˆ-0ï¼‰</span>
          </div>
        </div>
      </div>
    </div>

    <!-- ãƒ„ãƒ¢ -->
    <div class="gs-card">
      <div style="font-weight:900; margin-bottom:6px;">ãƒ„ãƒ¢ã®å ´åˆ</div>

      <!-- è‡ªåˆ†=å­ã®ã¨ãï¼šç›¸æ‰‹ãŒè¦ªã®å ´åˆ -->
      <div id="gyTsumoVsParent" class="gy-subCard hidden">
        <div style="font-weight:800; margin-bottom:6px;">ç›¸æ‰‹ãŒè¦ªã®å ´åˆ</div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">æ¡ä»¶ï¼š</div>
          <div class="gs-cardValue"><span id="gyTsumoNeed_vsParent">-</span></div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">è‡ªåˆ†ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyTsumoMeBefore_vsParent">-</span> â†’ <span id="gyTsumoMeAfter_vsParent">-</span>
            <span id="gyTsumoMeDelta_vsParent" class="gy-delta">ï¼ˆ+0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">ãƒˆãƒƒãƒ—ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyTsumoTopBefore_vsParent">-</span> â†’ <span id="gyTsumoTopAfter_vsParent">-</span>
            <span id="gyTsumoTopDelta_vsParent" class="gy-delta negative">ï¼ˆ-0ï¼‰</span>
          </div>
        </div>
      </div>

      <!-- è‡ªåˆ†=å­ã®ã¨ãï¼šç›¸æ‰‹ãŒå­ã®å ´åˆ / è‡ªåˆ†=è¦ªã®ã¨ãï¼šã“ã®ãƒ–ãƒ­ãƒƒã‚¯ã ã‘è¡¨ç¤º -->
      <div id="gyTsumoVsChild" class="gy-subCard">
        <div style="font-weight:800; margin-bottom:6px;">ç›¸æ‰‹ãŒå­ã®å ´åˆ</div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">æ¡ä»¶ï¼š</div>
          <div class="gs-cardValue"><span id="gyTsumoNeed_vsChild">-</span></div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">è‡ªåˆ†ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyTsumoMeBefore_vsChild">-</span> â†’ <span id="gyTsumoMeAfter_vsChild">-</span>
            <span id="gyTsumoMeDelta_vsChild" class="gy-delta">ï¼ˆ+0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">ãƒˆãƒƒãƒ—ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyTsumoTopBefore_vsChild">-</span> â†’ <span id="gyTsumoTopAfter_vsChild">-</span>
            <span id="gyTsumoTopDelta_vsChild" class="gy-delta negative">ï¼ˆ-0ï¼‰</span>
          </div>
        </div>
      </div>

      <!-- 3éº»4äººå›ã—ï¼šæŠœã‘ç•ªï¼ˆå¿…è¦ãªã‚‰è¡¨ç¤ºï¼‰ -->
      <div id="gyTsumoNuke" class="gy-subCard hidden">
        <div style="font-weight:800; margin-bottom:6px;">ç›¸æ‰‹ãŒæŠœã‘ç•ª</div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">æ¡ä»¶ï¼š</div>
          <div class="gs-cardValue"><span id="gyTsumoNeed_nuke">-</span></div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">è‡ªåˆ†ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyTsumoMeBefore_nuke">-</span> â†’ <span id="gyTsumoMeAfter_nuke">-</span>
            <span id="gyTsumoMeDelta_nuke" class="gy-delta">ï¼ˆ+0ï¼‰</span>
          </div>
        </div>

        <div class="gs-cardRow">
          <div class="gs-cardLabel">ãƒˆãƒƒãƒ—ï¼š</div>
          <div class="gs-cardValue">
            <span id="gyTsumoTopBefore_nuke">-</span> â†’ <span id="gyTsumoTopAfter_nuke">-</span>
            <span id="gyTsumoTopDelta_nuke" class="gy-delta negative">ï¼ˆ-0ï¼‰</span>
          </div>
        </div>
      </div>

    </div><!-- /ãƒ„ãƒ¢ã‚«ãƒ¼ãƒ‰ -->

  </div><!-- /ts-body -->
</div><!-- /gyakuSheet -->




<!-- =========================
     å±¥æ­´ï¼ˆç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
========================= -->
<div id="historyOverlay" class="ts-overlay hidden" onclick="closeHistorySheet()"></div>

<div id="historySheet" class="ts-sheet hidden" role="dialog" aria-modal="true">
  <div class="ts-handle"></div>

  <div class="ts-header">
    <div class="ts-title">å±¥æ­´</div>
    <button class="ts-close" onclick="closeHistorySheet()">Ã—</button>
  </div>

  <div id="historyList" class="historyList"></div>
</div>


<!-- ========================================= -->
<!-- é›†è¨ˆä¸­ç”»é¢ -->
<!-- ========================================= -->
<div id="calculatingScreen" class="hidden">
  <h2>é›†è¨ˆ</h2>

  <!-- 006ï¼ˆä¸Šï¼‰ -->
  <div id="calcTopName" style="text-align:center; margin-bottom:10px;">-</div>

  <!-- 002ï¼ˆä¸Šã®ãƒœã‚¿ãƒ³ï¼‰ -->
  <div style="text-align:center; margin-bottom:6px;">
    <button id="btnYakitoriTop" class="yakitoriBtn" onclick="toggleYakitoriByPos('N')">
      <img class="yakitoriBtnImg" src="image/yakitori_off.png" alt="ãƒ¤ã‚­ãƒˆãƒª">
    </button>
  </div>

  <!-- 010ï¼ˆä¸Šã®ã‚¹ã‚³ã‚¢è¡¨ç¤ºï¼‰ -->
  <div id="calcTopScore" style="text-align:center; margin-bottom:18px;">-</div>

  <!-- å·¦å³ï¼ˆ001/003 ãƒœã‚¿ãƒ³ã€005/007 åå‰ã€009/011 ã‚¹ã‚³ã‚¢ï¼‰ -->
  <div style="display:flex; justify-content:space-between; align-items:center; margin:16px 0;">
    <div style="width:40%; text-align:left;">
      <div id="calcLeftName">-</div> <!-- 005 -->
      <!-- å·¦ -->
        <button id="btnYakitoriLeft" class="yakitoriBtn" onclick="toggleYakitoriByPos('W')">
          <img class="yakitoriBtnImg" src="image/yakitori_off.png" alt="ãƒ¤ã‚­ãƒˆãƒª">
        </button>
      <div id="calcLeftScore">-</div> <!-- 009 -->
    </div>

    <div style="width:40%; text-align:right;">
      <div id="calcRightName">-</div> <!-- 007 -->
        <!-- å³ -->
        <button id="btnYakitoriRight" class="yakitoriBtn" onclick="toggleYakitoriByPos('S')">
          <img class="yakitoriBtnImg" src="image/yakitori_off.png" alt="ãƒ¤ã‚­ãƒˆãƒª">
        </button>
      <div id="calcRightScore">-</div> <!-- 011 -->
    </div>
  </div>

  <!-- è‡ªåˆ†ï¼ˆ008 åå‰ / 004 ãƒ¤ã‚­ãƒˆãƒªãƒœã‚¿ãƒ³ / 012 ã‚¹ã‚³ã‚¢ï¼‰ -->
  <div style="text-align:center; margin-top:20px;">
    <div id="calcMyName">-</div> <!-- 008 -->
      <!-- è‡ªåˆ† -->
      <button id="btnYakitoriMe" class="yakitoriBtn" onclick="toggleYakitoriByPos('ME')">
        <img class="yakitoriBtnImg" src="image/yakitori_off.png" alt="ãƒ¤ã‚­ãƒˆãƒª">
      </button>
    <div id="calcMyScore" style="margin-top:6px;">-</div> <!-- 012 -->
  </div>

  <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
    <button id="btnCalcEnd" onclick="finishCalculating()">é›†è¨ˆå®Œäº†</button> <!-- 013 -->
    <button onclick="backToRoomList()">ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸æˆ»ã‚‹</button> <!-- 014 -->
  </div>
</div>

<!-- ========================================= -->
<!-- å¯¾å±€çµ‚äº†ç”»é¢ -->
<!-- ========================================= -->
<div id="endScreen" class="hidden">
  <h2>å¯¾å±€çµ‚äº†</h2>

  <div style="margin-bottom:12px;">
    ãƒ«ãƒ¼ãƒ«ï¼š<button id="endRuleBtn" disabled>-</button> <!-- 001 -->
    <div>åŸç‚¹ï¼š<span id="endStartPoint">-</span></div>  <!-- 002 -->
    <div>è¿”ã—ç‚¹ï¼š<span id="endReturnPoint">-</span></div> <!-- 003 -->
  </div>

  <!-- é †ä½è¡¨ç¤º -->
  <div id="endRankGrid" style="display:grid; grid-template-columns: repeat(4, 1fr); gap:12px; text-align:center;">
    <!-- 1ä½ -->
    <div>
      <div>1ä½</div>
      <div id="rank1Name">-</div>  <!-- 004 -->
      <div id="rank1Score">-</div> <!-- 008 -->
      <div id="rank1Yakitori"></div> <!-- 012 -->
    </div>

    <!-- 2ä½ -->
    <div>
      <div>2ä½</div>
      <div id="rank2Name">-</div>  <!-- 005 -->
      <div id="rank2Score">-</div> <!-- 009 -->
      <div id="rank2Yakitori"></div> <!-- 013 -->
    </div>

    <!-- 3ä½ -->
    <div>
      <div>3ä½</div>
      <div id="rank3Name">-</div>  <!-- 006 -->
      <div id="rank3Score">-</div> <!-- 010 -->
      <div id="rank3Yakitori"></div> <!-- 014 -->
    </div>

    <!-- 4ä½ -->
    <div id="rank4Box">
      <div>4ä½</div>
      <div id="rank4Name">-</div>  <!-- 007 -->
      <div id="rank4Score">-</div> <!-- 011 -->
      <div id="rank4Yakitori"></div> <!-- 015 -->
    </div>
  </div>

  <div style="margin-top:18px; text-align:center;">
    <!-- â˜…è¿½åŠ ï¼šå±¥æ­´ãƒœã‚¿ãƒ³ -->
    <button id="btnEndHistory" onclick="openEndHistorySheet()">å±¥æ­´</button>

    <div style="height:10px;"></div>

    <button onclick="backToRoomList()">ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸æˆ»ã‚‹</button> <!-- 016 -->
  </div>
</div>


<script>
// ============================================
//                  ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
// ================= Firebase =================
if (!window.firebaseConfig && typeof firebaseConfig === "undefined") {
  alert("firebaseConfig ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚firebaseConfig.js ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
  throw new Error("firebaseConfig missing");
}
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
firebase.initializeApp(window.firebaseConfig);
const db = firebase.database();

// ===== DOMå‚ç…§ã‚’æ˜ç¤ºï¼ˆidã®è‡ªå‹•ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¾å­˜ã—ãªã„ï¼‰=====
const transferSheet   = document.getElementById("transferSheet");
const transferOverlay = document.getElementById("transferOverlay");
const loginScreen      = document.getElementById("loginScreen");
const playerConfigScreen = document.getElementById("playerConfigScreen");
const roomListScreen   = document.getElementById("roomListScreen");
const roomCreateScreen = document.getElementById("roomCreateScreen");
const addPlayerScreen  = document.getElementById("addPlayerScreen");
const gameScreen       = document.getElementById("gameScreen");
const calculatingScreen= document.getElementById("calculatingScreen");
const endScreen        = document.getElementById("endScreen");
const loginPass        = document.getElementById("loginPass");
const roomList         = document.getElementById("roomList");
const newPlayerName    = document.getElementById("newPlayerName");
const receiveSheet    = document.getElementById("receiveSheet");
const receiveOverlay  = document.getElementById("receiveOverlay");
const historySheet    = document.getElementById("historySheet");
const historyOverlay  = document.getElementById("historyOverlay");
const historyList     = document.getElementById("historyList");
const gyakuSheet    = document.getElementById("gyakuSheet");
const gyakuOverlay  = document.getElementById("gyakuOverlay");

const APP_STATE_KEY = "mahjong_app_state";

// ============== ç«¯æœ«/ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç´ã¥ã‘ç”¨ï¼ˆè¿½åŠ ï¼‰ ==============
let myDeviceId = null;   // UUID
let myPlayerId = null;   // deviceMapã‹ã‚‰é€†å¼•ãã—ãŸplayerId

// ================= çŠ¶æ…‹ =================
let currentRoomId = null;
let currentRule = null;
let currentGameInfo = {
  playerId: null,
  direction: null,
  status: null
}
let isSpectatorMode = false;
let calcUnsub = null;
let transferUnsub = null;
// â˜…è¿½åŠ ï¼šstopAllSubscriptions ã‹ã‚‰å‚ç…§ã•ã‚Œã‚‹ã®ã§ä¸Šã®æ–¹ã§å®£è¨€ã—ã¦ãŠã
let endUnsub = null;
let statusUnsub = null;   // stopAllSubscriptionsã§è§¦ã£ã¦ã‚‹ãªã‚‰ã“ã‚Œã‚‚åŒæ§˜ã«ä¸Šã¸
let gameStateUnsub = null; // åŒæ§˜
let roomsUnsub = null;     // åŒæ§˜
let entryPlayersUnsub = null; // åŒæ§˜
let historyUnsub = null;   // åŒæ§˜
let gyakuUnsub = null;     // åŒæ§˜

// ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ç”¨
let entryPlayers = {};

const RULES = {"3":"3éº»", "3r4":"3éº»4äºº", "4":"4éº»"};
const GAME_STATUS = {"waiting": "å¾…æ©Ÿ","playing": "å¯¾å±€", "calculating": "é›†è¨ˆ", "end":"çµ‚äº†"}

// å…¨ç”»é¢éè¡¨ç¤º
function hideAllScreens() {
  loginScreen.classList.add("hidden");
  playerConfigScreen?.classList.add("hidden");
  roomListScreen.classList.add("hidden");
  roomCreateScreen?.classList.add("hidden");
  addPlayerScreen.classList.add("hidden");
  gameScreen.classList.add("hidden");
  calculatingScreen.classList.add("hidden");
  endScreen.classList.add("hidden");

  // â˜…è¿½åŠ 
  document.getElementById("playerConfigScreen")?.classList.add("hidden");
}

// ç”»é¢è¡¨ç¤º
function showScreen(id) {
  hideAllScreens();
  document.getElementById(id)?.classList.remove("hidden");
  saveAppState(id); // ç”»é¢IDã‚’ãã®ã¾ã¾ä¿å­˜ã—ã¦OKï¼ˆå¾Œã§å¾©å¸°ï¼‰
}

// ================= ãƒ­ã‚°ã‚¤ãƒ³ =================
async function login() {
  const pass = (loginPass?.value ?? "").trim();

  if (!pass) {
    alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
    return;
  }

  try {
    const snap = await db.ref("systemConfig/loginPass").once("value");

    if (!snap.exists()) {
      alert("DBã« systemConfig/loginPass ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚ãƒ‘ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
      return;
    }

    const dbPass = String(snap.val() ?? "").trim();

    // â˜…å‹é•ã„ï¼ˆæ•°å€¤/æ–‡å­—åˆ—ï¼‰ã§ã‚‚ä¸€è‡´ã§ãã‚‹ã‚ˆã†ã« String æ¯”è¼ƒ
    if (dbPass !== String(pass)) {
      alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™ã€‚");
      return;
    }

    // æˆåŠŸ
    await bootstrapAfterLogin();

  } catch (e) {
    console.error("login error:", e);
    alert("Firebaseèª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã® login error ã‚’è¦‹ã¦ãã ã•ã„ã€‚\n" + (e?.message ?? e));
  }
}


async function bootstrapAfterLogin() {
  loginScreen.classList.add("hidden");
  // 1) deviceIdå–å¾—
  myDeviceId = getOrCreateDeviceId();
  if (!myDeviceId) {
    // ã¾ãšã“ã“ã¯ã»ã¼èµ·ããªã„ãŒå¿µã®ãŸã‚
    myPlayerId = null;
    await openPlayerConfigScreen("deviceIdãŒå–å¾—ã§ãã¾ã›ã‚“ã€‚å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚");
    return;
  }

  // 2) deviceMap/{deviceId} ã‚’å‚ç…§
  const snap = await db.ref(`deviceMap/${myDeviceId}`).once("value");
  const map = snap.val();

  // 3) playerIdå–ã‚Œã‚Œã°ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸ã€å–ã‚Œãªã‘ã‚Œã°ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã¸
  if (map && map.playerId) {
    myPlayerId = map.playerId;
    showRoomListScreen();
    return;
  }

  myPlayerId = null;
  await openPlayerConfigScreen("");
}

const DEVICE_ID_KEY = "mahjong_device_id";

function getOrCreateDeviceId() {
  let id = localStorage.getItem(DEVICE_ID_KEY);
  if (id) return id;

  // crypto.randomUUID ãŒä½¿ãˆã‚‹ãªã‚‰ãã‚Œã‚’ä½¿ã†
  if (crypto?.randomUUID) {
    id = crypto.randomUUID();
  } else {
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆååˆ†ãƒ¦ãƒ‹ãƒ¼ã‚¯ï¼‰
    id = "xxxxxxxxyxxx4xxxyxxxxyxxxxxxxxxxx".replace(/[xy]/g, c => {
      const r = (Math.random() * 16) | 0;
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  localStorage.setItem(DEVICE_ID_KEY, id);
  return id;
}

async function openPlayerConfigScreen(msg) {
  showScreen("playerConfigScreen");

  const msgEl = document.getElementById("playerConfigMsg");
  if (msgEl) msgEl.textContent = msg || "";

  // entryPlayersã‚’ãƒ­ãƒ¼ãƒ‰ã—ã¦ãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ä½œã‚‹
  const snap = await db.ref("systemConfig/entryPlayers").once("value");
  const list = snap.val() || {};

  const sel = document.getElementById("playerConfigSelect");
  sel.innerHTML = "";

  // 1ä»¶ã‚‚ç„¡ã„å ´åˆ
  const keys = Object.keys(list);
  if (keys.length === 0) {
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæœªç™»éŒ²ã§ã™";
    sel.appendChild(opt);
    document.getElementById("btnPlayerConfigDone").disabled = true;
    return;
  }

  document.getElementById("btnPlayerConfigDone").disabled = false;

  // optionä½œæˆ
  for (const pid of keys) {
    const opt = document.createElement("option");
    opt.value = pid;
    opt.textContent = list[pid]?.name ?? pid;
    sel.appendChild(opt);
  }
}

async function completePlayerConfig() {
  const sel = document.getElementById("playerConfigSelect");
  let pid = sel?.value;

  if (!pid) {
    document.getElementById("playerConfigMsg").textContent = "ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚";
    return;
  }

  pid = String(pid).trim(); // â˜…å¿µã®ãŸã‚ï¼ˆç©ºç™½æ··å…¥å¯¾ç­–ï¼‰

  myDeviceId = myDeviceId || getOrCreateDeviceId();
  if (!myDeviceId) {
    document.getElementById("playerConfigMsg").textContent = "deviceIdã‚’å–å¾—ã§ãã¾ã›ã‚“ã€‚";
    return;
  }

  try {
    // 1) pid ã«ä¸€è‡´ã™ã‚‹ deviceMap/{deviceId} ã‚’å…¨ä»¶å–å¾—
    const snap = await db
      .ref("deviceMap")
      .orderByChild("playerId")
      .equalTo(pid)
      .once("value");

    // 2) ä¸€è‡´ã—ãŸ deviceId ãƒãƒ¼ãƒ‰ã‚’å…¨éƒ¨å‰Šé™¤ï¼ˆdeviceMap/{deviceId} = nullï¼‰
    if (snap.exists()) {
      const updates = {};
      snap.forEach(child => {
        const deviceId = child.key;
        if (!deviceId) return;
        updates[`deviceMap/${deviceId}`] = null; // â˜…ãƒãƒ¼ãƒ‰ä¸¸ã”ã¨å‰Šé™¤
      });

      // é‡è¦ï¼šupdateå¯¾è±¡ãŒã‚ã‚‹ã¨ãã ã‘å©ã
      if (Object.keys(updates).length) {
        await db.ref().update(updates);
      }
    }

    // 3) ãã®å¾Œã«ç™»éŒ²ï¼ˆã“ã‚Œã§æœ€çµ‚çš„ã« myDeviceId ã®ã¿æ®‹ã‚‹ï¼‰
    await db.ref(`deviceMap/${myDeviceId}`).set({
      playerId: pid,
      updatedAt: Date.now(),
      lastRoomId: null
    });

    myPlayerId = pid;
    try { updateMyPlayerLabel?.(); } catch {}
    showRoomListScreen();

  } catch (e) {
    console.error("completePlayerConfig error:", e);
    document.getElementById("playerConfigMsg").textContent =
      `å‡¦ç†ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e?.message || e}`;
  }
}


let addPlayerReturnTo = null; // "playerConfig" or "playerSetup"

function openAddPlayerFromPlayerConfig() {
  addPlayerReturnTo = "playerConfig";
  showScreen("addPlayerScreen");
}

function openAddPlayer() {
  // æ—¢å­˜ã®å‚åŠ è€…è¨­å®šç”»é¢ã‹ã‚‰å‘¼ã¶å ´åˆ
  addPlayerReturnTo = "playerSetup";
  addPlayerScreen.classList.remove("hidden");
  saveAppState("addPlayerScreen");
}

function backToPlayerSetup() {
  addPlayerScreen.classList.add("hidden");

  if (addPlayerReturnTo === "playerConfig") {
    openPlayerConfigScreen("");
    return;
  }
}

function goRoomList() {
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã‹ã‚‰æˆ»ã‚‹ãƒœã‚¿ãƒ³ç”¨
  showRoomListScreen();
}


// ================= ãƒ«ãƒ¼ãƒ ä¸€è¦§ =================
function loadRooms() {
  roomList.innerHTML = "";

  // ãƒ˜ãƒƒãƒ€ãƒ¼
  const header = document.createElement("div");
  header.style.fontWeight = "bold";
  header.style.display = "flex";
  header.style.gap = "10px";
  header.innerHTML = `
    <div style="width:150px;">ãƒ«ãƒ¼ãƒ ID</div>
    <div style="width:100px;">ãƒ«ãƒ¼ãƒ«</div>
    <div style="width:100px;">çŠ¶æ…‹</div>
    <div style="width:100px;">å¾…æ©Ÿäººæ•°</div>
    <div style="flex:1;">æ“ä½œ</div>
  `;
  roomList.appendChild(header);
}


// ===== ãƒ«ãƒ¼ãƒ ä¸€è¦§ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è³¼èª­ =====
let roomsCache = {};

function subscribeRooms() {
  const ref = db.ref("rooms");

  if (roomsUnsub) roomsUnsub();

  const handler = (snap) => {
    try {
      const rooms = snap.val() || {};
      renderRoomList(rooms);
      if (roomList.children.length === 0) { // headerã—ã‹ãªã„
        const div = document.createElement("div");
        div.style.padding = "8px 0";
        div.textContent = "ãƒ«ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆã¾ãŸã¯è¡¨ç¤ºå¯¾è±¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“ï¼‰";
        roomList.appendChild(div);
      }
    } catch (e) {
      console.error("renderRoomList error:", e);
      alert("ãƒ«ãƒ¼ãƒ ä¸€è¦§æç”»ã§ã‚¨ãƒ©ãƒ¼ã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
    }
  };

  const onError = (err) => {
    console.error("rooms subscribe error:", err);
    alert("rooms ã®èª­ã¿å–ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸã€‚DBæ¨©é™ã‚„ãƒ‘ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
  };

  ref.on("value", handler, onError);
  roomsUnsub = () => ref.off("value", handler);

  ref.once("value").then(handler).catch(onError);
}

function renderRoomList(rooms) {
  roomsCache = rooms || {};

  // â˜…è¡Œä¸€è¦§ã¯ã“ã“ã«æãï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é ˜åŸŸï¼‰
  roomList.innerHTML = "";

  // â˜…åˆ—ãƒ˜ãƒƒãƒ€ãƒ¼ã¯å›ºå®šé ˜åŸŸã¸
  const headerHost = document.getElementById("roomListTableHeader");
  if (headerHost) headerHost.innerHTML = "";

  const header = document.createElement("div");
  header.className = "roomListHeader";
  header.innerHTML = `
    <div class="roomCell">ãƒ«ãƒ¼ãƒ ID</div>
    <div class="roomCell">ãƒ«ãƒ¼ãƒ«</div>
    <div class="roomCell">çŠ¶æ…‹</div>
    <div class="roomCell">å‚åŠ è€…</div>
    <div class="roomCell">æ“ä½œ</div>
  `;
  if (headerHost) headerHost.appendChild(header);

  const statusAllow = ["waiting","playing","calculating","end"];
  const statusOrder = { waiting:0, playing:1, calculating:2, end:3 };

  // direction -> pid ã‚’æ¢ã™
  const findPidByDir = (playersObj, dir) => {
    if (!playersObj) return null;
    for (const [pid, p] of Object.entries(playersObj)) {
      if (p?.direction === dir) return pid;
    }
    return null;
  };

  const nameByPid = (pid) => {
    if (!pid) return "-";
    return entryPlayers?.[pid]?.name ?? pid;
  };

  // ============================
  // â˜…ã‚½ãƒ¼ãƒˆï¼ˆstatusé † â†’ ãƒ«ãƒ¼ãƒ IDæ˜‡é †ï¼‰
  // ============================
  const entries = Object.entries(roomsCache)
    .map(([id, r]) => {
      const status = r?.gameConfig?.status ?? "-";
      return { id, r: r || {}, status };
    })
    .filter(x => statusAllow.includes(x.status))
    .sort((a, b) => {
      const ao = statusOrder[a.status] ?? 99;
      const bo = statusOrder[b.status] ?? 99;
      if (ao !== bo) return ao - bo;

      // ç¬¬2æ¡ä»¶ï¼šãƒ«ãƒ¼ãƒ ID æ˜‡é †ï¼ˆæ–‡å­—åˆ—ã§OKï¼‰
      return String(a.id).localeCompare(String(b.id));
    });

  // è¡Œã‚’æç”»
  for (const x of entries) {
    const id = x.id;
    const r = x.r;
    const status = x.status;

    const ruleText = RULES[r.gameConfig?.rule] || r.gameConfig?.rule || "-";
    const stText   = GAME_STATUS[status] || status;

    const pidE = findPidByDir(r.players, "æ±");
    const pidS = findPidByDir(r.players, "å—");
    const pidW = findPidByDir(r.players, "è¥¿");
    const pidN = findPidByDir(r.players, "åŒ—");

    const row = document.createElement("div");
    row.className = "roomListRow";

    const btnEnter = (["waiting","playing","calculating"].includes(status))
      ? `<button onclick="enterRoom('${id}')">å…¥å®¤</button>` : "";

    const btnResult = (status === "end")
      ? `<button onclick="enterRoom('${id}')">çµæœ</button>` : "";

    const btnDelete = (status === "waiting")
      ? `<button onclick="deleteRoom('${id}')">å‰Šé™¤</button>` : "";

    row.innerHTML = `
      <div class="roomCell">${id}</div>
      <div class="roomCell">${ruleText}</div>
      <div class="roomCell">${stText}</div>

      <div class="roomCell">
        <div>${nameByPid(pidE)}</div>
        <div>${nameByPid(pidS)}</div>
        <div>${nameByPid(pidW)}</div>
        <div>${nameByPid(pidN)}</div>        
      </div>

      <div class="roomCell">
        <div class="ops">
          ${btnEnter}
          ${btnResult}
          ${btnDelete}
        </div>
      </div>
    `;

    roomList.appendChild(row);
  }

  // 0ä»¶ã®ã¨ã
  if (entries.length === 0) {
    const div = document.createElement("div");
    div.style.padding = "8px 0";
    div.textContent = "ãƒ«ãƒ¼ãƒ ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆã¾ãŸã¯è¡¨ç¤ºå¯¾è±¡ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã‚ã‚Šã¾ã›ã‚“ï¼‰";
    roomList.appendChild(div);
  }
}



// entryPlayers ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è³¼èª­ã™ã‚‹é–¢æ•°
function subscribeEntryPlayers() {
  const ref = db.ref("systemConfig/entryPlayers");

  if (entryPlayersUnsub) entryPlayersUnsub();

  const handler = (snap) => {
    entryPlayers = snap.val() || {};
    // ãƒ«ãƒ¼ãƒ ä¸€è¦§ãŒå‡ºã¦ã„ã‚‹ãªã‚‰å†æç”»
    renderRoomList(roomsCache);
    updateMyPlayerLabel();   // â˜…è¿½åŠ 
  };

  ref.on("value", handler);
  entryPlayersUnsub = () => ref.off("value", handler);

  ref.once("value").then(handler).catch(e => console.error("entryPlayers load error:", e));
}

// è³¼èª­é–‹å§‹
function showRoomListScreen() {
  showScreen("roomListScreen");
  subscribeEntryPlayers();   // â˜…è¿½åŠ 
  subscribeRooms();
  updateMyPlayerLabel();   // â˜…è¿½åŠ ï¼ˆentryPlayersæœªèª­è¾¼ã§ã‚‚å¾Œã§ä¸Šæ›¸ãã•ã‚Œã‚‹ï¼‰
}


function updateMyPlayerLabel() {
  const el = document.getElementById("myPlayerLabel");
  if (!el) return;

  if (!myPlayerId) {
    el.textContent = "";
    return;
  }

  const name = entryPlayers?.[myPlayerId]?.name;
  el.textContent = name ? `ğŸ‘¤ ${name}` : "";
}

// ---------------------------
// ãƒ«ãƒ¼ãƒ ä½œæˆç”»é¢ï¼ˆæ–°è¦ï¼‰
// ---------------------------
const createSeatIds = [
  ["æ±", "createSeatE"],
  ["å—", "createSeatS"],
  ["è¥¿", "createSeatW"],
  ["åŒ—", "createSeatN"],
];

function openRoomCreateScreen() {
  showScreen("roomCreateScreen");
  loadEntryPlayersForCreate();
}

async function loadEntryPlayersForCreate() {
  const msgEl = document.getElementById("roomCreateMsg");
  if (msgEl) msgEl.textContent = "";

  const snap = await db.ref("systemConfig/entryPlayers").once("value");
  const list = snap.val() || {};

  // optionç”Ÿæˆï¼ˆå…¨å¸­å…±é€šï¼‰
  for (const [, selId] of createSeatIds) {
    const sel = document.getElementById(selId);
    if (!sel) continue;

    sel.innerHTML = "";

    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = "æœªé¸æŠ";
    sel.appendChild(opt0);

    for (const [pid, p] of Object.entries(list)) {
      const opt = document.createElement("option");
      opt.value = pid;
      opt.textContent = p?.name ?? pid;
      sel.appendChild(opt);
    }

    sel.addEventListener("change", validateCreateRoomForm);
  }

  // ãƒ«ãƒ¼ãƒ«/ç‚¹æ•°ã‚‚å¤‰æ›´æ™‚ã«æ¤œè¨¼
  document.querySelectorAll("input[name=create_rule]").forEach(r => {
    r.addEventListener("change", validateCreateRoomForm);
  });
  document.getElementById("createStartPoint")?.addEventListener("input", validateCreateRoomForm);
  document.getElementById("createReturnPoint")?.addEventListener("input", validateCreateRoomForm);

  validateCreateRoomForm();
}

function getCreateRule() {
  return document.querySelector("input[name=create_rule]:checked")?.value || "3";
}

function validateCreateRoomForm() {
  const rule = getCreateRule();
  const need = (rule === "3") ? 3 : 4;

  const start = parseInt(document.getElementById("createStartPoint")?.value, 10) || 0;
  const ret   = parseInt(document.getElementById("createReturnPoint")?.value, 10) || 0;

  const picks = [];
  for (const [dir, selId] of createSeatIds) {
    const v = document.getElementById(selId)?.value || "";
    if (v) picks.push({ dir, pid: v });
  }

  const msgEl = document.getElementById("roomCreateMsg");
  const btn = document.getElementById("btnCreateRoomDo");

  // åŸç‚¹ <= è¿”ã—ç‚¹
  if (start > ret) {
    if (msgEl) msgEl.textContent = "åŸç‚¹ã¯è¿”ã—ç‚¹ä»¥ä¸‹ã«ã—ã¦ãã ã•ã„ã€‚";
    if (btn) btn.disabled = true;
    return;
  }

  // é‡è¤‡ãƒã‚§ãƒƒã‚¯
  const ids = picks.map(x => x.pid);
  const unique = new Set(ids);
  if (unique.size !== ids.length) {
    if (msgEl) msgEl.textContent = "åŒã˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¤‡æ•°å¸­ã«ã„ã¾ã™ã€‚";
    if (btn) btn.disabled = true;
    return;
  }

  // äººæ•°ãƒã‚§ãƒƒã‚¯
  if (picks.length !== need) {
    if (msgEl) msgEl.textContent = `å¸­ã‚’${need}äººåˆ†é¸æŠã—ã¦ãã ã•ã„ã€‚`;
    if (btn) btn.disabled = true;
    return;
  }

  if (msgEl) msgEl.textContent = "";
  if (btn) btn.disabled = false;
}

async function createRoomFromCreateScreen() {
  validateCreateRoomForm();
  const btn = document.getElementById("btnCreateRoomDo");
  if (btn?.disabled) return;

  const rule = getCreateRule();
  const startPoint  = parseInt(document.getElementById("createStartPoint")?.value, 10) || 45000;
  const returnPoint = parseInt(document.getElementById("createReturnPoint")?.value, 10) || 50000;

  // é¸æŠå¸­ã‚’é›†ã‚ã‚‹
  const selected = [];
  for (const [dir, selId] of createSeatIds) {
    const pid = document.getElementById(selId)?.value || "";
    if (pid) selected.push({ dir, pid });
  }

  const need = (rule === "3") ? 3 : 4;
  if (selected.length !== need) return;

  // ãƒ«ãƒ¼ãƒ IDï¼ˆæ—¢å­˜ã¨åŒã˜å½¢å¼ï¼‰
  const d = new Date();
  const pad = (n) => n.toString().padStart(2, "0");
  const roomId = `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;

  // players ã‚’çµ„ã¿ç«‹ã¦
  const playersObj = {};
  for (const x of selected) {
    playersObj[x.pid] = {
      direction: x.dir,
      status: "waiting",
      point: startPoint,
      score: null,
      yakitoriFlg: true
    };
  }

  await db.ref(`rooms/${roomId}`).set({
    gameConfig: {
      startPoint,
      returnPoint,
      rule,
      status: "waiting",
      riichiStickCount: 0,
      createdAt: firebase.database.ServerValue.TIMESTAMP
    },
    players: playersObj,
    transferRequests: {}
  });

  // ä½œã£ãŸã‚‰ä¸€è¦§ã¸
  backToRoomList();
}

// æ™‚åˆ»ãƒ¦ãƒ‹ãƒ¼ã‚¯IDç”Ÿæˆ
function genTransferRequestId(){
  const d = new Date();
  const pad2 = (n) => String(n).padStart(2, "0");
  const pad3 = (n) => String(n).padStart(3, "0");

  const ymd = `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}`;
  const hms = `${pad2(d.getHours())}${pad2(d.getMinutes())}${pad2(d.getSeconds())}`;
  const ms  = pad3(d.getMilliseconds());
  const rnd = pad3(Math.floor(Math.random() * 1000));

  return `${ymd}_${hms}_${ms}_${rnd}`;
}


// å‚åŠ è€…è¨­å®šå‡¦ç†ï¼ˆå…¥å®¤ï¼‰
// deviceId -> myPlayerId ã‚’å…ƒã«ã€è‡ªåˆ†ã®directionã‚’ç¢ºå®šã—ã¦æç”»ã™ã‚‹
async function enterRoom(id) {
  try {
    stopAllSubscriptions?.();
    historyCache = [];
    if (historyUnsub) { historyUnsub(); historyUnsub = null; }

    currentRoomId = id;

    if (!myPlayerId) {
      await openPlayerConfigScreen("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šãŒæœªå®Œäº†ã§ã™ã€‚å…ˆã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚");
      return;
    }

    const roomSnap = await db.ref(`rooms/${id}`).once("value");
    if (!roomSnap.exists()) {
      alert("ãƒ«ãƒ¼ãƒ ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚");
      backToRoomList();
      return;
    }

    const room = roomSnap.val() || {};
    const gameConfig = room.gameConfig || {};
    const players = room.players || {};

    currentRule = gameConfig.rule || null;

    const my = players[myPlayerId];

    console.log("[enterRoom]", {
      myPlayerId,
      playersKeys: Object.keys(players || {}),
      hasMe: !!players?.[myPlayerId],
      my: players?.[myPlayerId],
    });

    // ===== è¦³æˆ¦åˆ¤å®š =====
    if (!my || !my.direction) {
      // è¦³æˆ¦ãƒ¢ãƒ¼ãƒ‰
      isSpectatorMode = true;

      currentGameInfo.playerId = null;     // è¦³æˆ¦ã¯è‡ªåˆ†pidç„¡ã—
      currentGameInfo.direction = "æ±";    // è¦³æˆ¦ã®åŸºæº–æ–¹è§’ï¼ˆç›¸å¯¾å¤‰æ›ç”¨ã«ä½¿ã†å ´åˆã®ä¿é™ºï¼‰
      currentGameInfo.status = "spectating";

      // çŠ¶æ…‹ã«å¿œã˜ã¦ç”»é¢ã¸ï¼ˆè¦³æˆ¦ã§ã‚‚ sameï¼‰
      const roomStatus = gameConfig.status || "waiting";

      if (roomStatus === "calculating") {
        openCalculatingScreen();
        saveAppState("calculatingScreen");
        return;
      }

      if (roomStatus === "end") {
        openEndScreen();
        saveAppState("endScreen");
        return;
      }

      openGameScreen();
      saveAppState("gameScreen");
      return;
    }

    // ===== é€šå¸¸å‚åŠ  =====
    isSpectatorMode = false;

    currentGameInfo.playerId = myPlayerId;
    currentGameInfo.direction = my.direction;
    currentGameInfo.status = my.status || "waiting";

    const roomStatus = gameConfig.status || "waiting";

    // â˜…è¿½åŠ ï¼šå…¥å®¤ã—ãŸã‚‰ waiting â†’ playing ã«æ›´æ–°
    await ensurePlayingOnEnter(id, myPlayerId);

    // ï¼ˆã“ã“ã‹ã‚‰æ—¢å­˜ã®åˆ†å²ï¼‰
    saveAppState("enterRoom");

    if (roomStatus === "calculating") {
      openCalculatingScreen();
      saveAppState("calculatingScreen");
      return;
    }

    if (roomStatus === "end") {
      openEndScreen();
      saveAppState("endScreen");
      return;
    }

    openGameScreen();
    saveAppState("gameScreen");
    if (entryPlayersUnsub) entryPlayersUnsub();

  } catch (e) {
    console.error("enterRoom error:", e);
    alert("å…¥å®¤å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚\n" + (e?.message ?? e));
    backToRoomList();
  }
}

// statuså¤‰æ›´åˆ¤å®š
async function ensurePlayingOnEnter(roomId, playerId) {
  if (!roomId || !playerId) return;

  const playerStatusRef = db.ref(`rooms/${roomId}/players/${playerId}/status`);
  const roomStatusRef   = db.ref(`rooms/${roomId}/gameConfig/status`);

  // ---- player status ----
  const pSnap = await playerStatusRef.once("value");
  const pStatus = pSnap.val();

  if (pStatus === "waiting") {
    await playerStatusRef.set("playing");
  }

  // ---- room status ----
  const rSnap = await roomStatusRef.once("value");
  const rStatus = rSnap.val();

  if (rStatus === "waiting") {
    await roomStatusRef.set("playing");
  }
}



// è¦³æˆ¦æ™‚ã¯æ“ä½œã‚’ç„¡åŠ¹åŒ–
function applySpectatorLockUI() {
  const btnBack = Array.from(gameScreen.querySelectorAll("button"))
    .find(b => (b.textContent || "").includes("ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸æˆ»ã‚‹"));

  const disableIds = ["btnRiichiAdd", "btnRiichiTake", "btnEndGame", "btnConfirm", "btnCancel"];
  for (const id of disableIds) {
    const el = document.getElementById(id);
    if (el) el.disabled = true;
  }

  // æ”¯æ‰•ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆã‚’é–‹ã‹ã›ãªã„ï¼ˆæ®‹ã£ã¦ãŸã‚‰é–‰ã˜ã‚‹ï¼‰
  try { closeTransferSheet(); } catch {}

  // è¦³æˆ¦ä¸­ã¯ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆè‡ªä½“è§¦ã‚Œãªã„ã‚ˆã†ã«ï¼ˆä»»æ„ï¼‰
  if (transferOverlay) transferOverlay.classList.add("hidden");
  if (transferSheet) transferSheet.classList.add("hidden");

  // ã€Œæˆ»ã‚‹ã€ä»¥å¤–ã®ãƒœã‚¿ãƒ³ã‚‚å…¨éƒ¨ç„¡åŠ¹åŒ–ï¼ˆä¿é™ºï¼‰
  const allButtons = Array.from(gameScreen.querySelectorAll("button"));
  for (const b of allButtons) {
    if (btnBack && b === btnBack) continue;
    // æˆ»ã‚‹ä»¥å¤– disable
    b.disabled = true;
  }
}



// ================= ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½åŠ  =================
function openAddPlayerFromRoomList() {
  addPlayerReturnTo = "roomList";
  showScreen("addPlayerScreen");
}

function addPlayer() {
  const name = newPlayerName.value.trim();
  if (!name) return;

  const id = "p" + Date.now();
  db.ref(`systemConfig/entryPlayers/${id}`).set({ name }).then(() => {
    newPlayerName.value = "";
    backToPlayerSetup();
  });
}


// ===============================
// å¯¾å±€ä¸­ ç”»é¢ç”¨ï¼ˆä¸€æ™‚çŠ¶æ…‹ï¼‰
// ===============================

let selectedRecipient = null; // 'N'|'W'|'S'
let sendAmountValue = 0;

// æ–¹å‘ã®å›è»¢ï¼šè‡ªåˆ†ãŒã©ã®directionã§ã‚‚ã€ç”»é¢ä¸Šã® N/W/S ã«ç›¸å¯¾é…ç½®ã™ã‚‹
// ä¾‹ï¼šè‡ªåˆ†ãŒæ±ãªã‚‰ N=åŒ— W=è¥¿ S=å—ï¼ˆç”»åƒä»•æ§˜ã®ä¾‹ã¨ä¸€è‡´ï¼‰
const DIRS = ["æ±","å—","è¥¿","åŒ—"];
function toRelative(selfDir, otherDir) {
  const si = DIRS.indexOf(selfDir);
  const oi = DIRS.indexOf(otherDir);
  if (si < 0 || oi < 0) return null;

  const diff = (oi - si + 4) % 4;

  // è‡ªåˆ†ã‚’ä¸‹å›ºå®šï¼šä¸Š=å¯¾é¢ã€å³=æ¬¡å¸­ã€å·¦=å‰å¸­
  if (diff === 1) return "S"; // å³
  if (diff === 2) return "N"; // ä¸Š(å¯¾é¢)
  if (diff === 3) return "W"; // å·¦
  return null; // diff===0 ã¯è‡ªåˆ†
}

function setText(id, text){ const el=document.getElementById(id); if(el) el.textContent = text; }

function setDiff(elId, diff){
  const el = document.getElementById(elId);
  if (!el) return;
  const v = Number(diff) || 0;
  el.textContent = (v >= 0 ? `+${v}` : `${v}`);
  el.classList.toggle("negative", v < 0);
}

// ===============================
// å¯¾å±€ç”»é¢ã‚’é–‹ã
// ===============================
function openGameScreen() {
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  gameScreen.classList.remove("hidden");
  historyCache = [];
  if (historyUnsub) { historyUnsub(); historyUnsub = null; }

  selectedRecipient = null;
  sendAmountValue = 0;
  setText("sendToName", "-");
  setText("sendAmount", "0");

  if (gameStateUnsub) gameStateUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);
    renderGameUI(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  gameStateUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };
  // â˜…ã“ã“ã‚’è¿½åŠ ï¼ˆè¦³æˆ¦ã¯é™¤å¤–ã—ãŸã„ãªã‚‰ã‚¬ãƒ¼ãƒ‰ï¼‰
  if (!isSpectatorMode) subscribeTransferRequests();
  handler();
  subscribeRoomStatus();
  
}

function subscribeRoomStatus() {
  if (!currentRoomId) return;

  const ref = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  if (statusUnsub) statusUnsub();

  const handler = (snap) => {
    const st = snap.val();
    if (st === "calculating") {
      openCalculatingScreen();
    }
    if (st === "end") {
      openEndScreen();
    }
  };

  ref.on("value", handler);
  statusUnsub = () => ref.off("value", handler);
}


// ===============================
// ç”»é¢æç”»ï¼ˆ001ã€œ012 ãªã©ï¼‰
// ===============================
function renderGameUI(players, gameConfig, entryPlayers){
  // â˜…è¦³æˆ¦ãƒ¢ãƒ¼ãƒ‰
  if (isSpectatorMode) {
    renderSpectatorUI(players, gameConfig, entryPlayers);
    return;
  }
  
  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return; // ã¾ã DBã«ã„ãªã„ç­‰

  // 001 è‡ªåˆ†ã®åå‰
  setText("myName", entryPlayers[myPid]?.name ?? "ä¸æ˜");

  // 012 è‡ªåˆ†ã®pointï¼ˆå¤§ããï¼‰
  const myPoint = Number(my.point ?? 0);
  setText("myPoint", myPoint);

  // 002 ãƒªãƒ¼ãƒæ£’æœ¬æ•°
  setText("riichiCount", Number(gameConfig.riichiStickCount ?? 0));

  // ç›¸æ‰‹æ ã‚’åˆæœŸåŒ–
  const slots = { N:null, W:null, S:null };
  for (const [pid, p] of Object.entries(players)){
    if (!p?.direction) continue;
    if (pid === myPid) continue;
    const rel = toRelative(my.direction, p.direction);
    if (rel) slots[rel] = { pid, p };
  }

  // N/W/S ã¸åæ˜ ï¼ˆ003ã€œ011ï¼‰
  // åŒ—æ 
  renderOpponentSlot("N", slots.N, entryPlayers, myPoint);
  // è¥¿æ 
  renderOpponentSlot("W", slots.W, entryPlayers, myPoint);
  // å—æ 
  renderOpponentSlot("S", slots.S, entryPlayers, myPoint);
  // ãƒ¤ã‚­ãƒˆãƒª
  setYakitoriImg("yakitoriME", players?.[myPid]?.yakitoriFlg === true);
}

function renderOpponentSlot(rel, slot, entryPlayers, myPoint){
  const nameId  = rel === "N" ? "nameN"  : rel === "W" ? "nameW"  : "nameS";
  const pointId = rel === "N" ? "pointN" : rel === "W" ? "pointW" : "pointS";
  const diffId  = rel === "N" ? "diffN"  : rel === "W" ? "diffW"  : "diffS";

  // ã‚¿ãƒƒãƒ—ã‚¨ãƒªã‚¢ï¼ˆåº§å¸­å…¨ä½“ï¼‰
  const seatSel = rel === "N" ? ".gs-north" : rel === "W" ? ".gs-west" : ".gs-south";
  const seatEl = document.querySelector(seatSel);

  // ã¾ãšã‚¯ãƒªãƒƒã‚¯è§£é™¤ï¼ˆæ¯å›ä¸Šæ›¸ãï¼‰
  if (seatEl) {
    seatEl.onclick = null;
    seatEl.classList.remove("tapTarget");
  }

  // ãƒ¤ã‚­ãƒˆãƒª img id
  const yId = rel === "N" ? "yakitoriN" : rel === "W" ? "yakitoriW" : "yakitoriS";

  // ç©ºå¸­
  if (!slot){
    setText(nameId, "-");
    setText(pointId, "-");
    setText(diffId, "-");
    document.getElementById(yId)?.classList.add("is-hidden");
    return;
  }

  // å¸­ã‚ã‚Š
  document.getElementById(yId)?.classList.remove("is-hidden");

  const { pid, p } = slot;

  // ãƒ¤ã‚­ãƒˆãƒªç”»åƒã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åæ˜ 
  setYakitoriImg(yId, p?.yakitoriFlg === true);

  const nm = entryPlayers[pid]?.name ?? "ä¸æ˜";
  const pt = Number(p.point ?? 0);

  setText(nameId, nm);
  setText(pointId, pt);
  setDiff(diffId, myPoint - pt);

  // åº§å¸­å…¨ä½“ã‚¿ãƒƒãƒ—ã§é€ã‚Šå…ˆé¸æŠ
  if (seatEl) {
    seatEl.classList.add("tapTarget");

    if (isSpectatorMode) {
      seatEl.onclick = null;
      seatEl.classList.remove("tapTarget");
    } else {
      seatEl.onclick = () => selectRecipient(rel);
    }
  }
}




// ===============================
// 013 ãƒªãƒ¼ãƒï¼šãƒªãƒ¼ãƒæ£’+1 / è‡ªåˆ†point-1000
// ===============================
async function onRiichiAdd(){
  if (!currentRoomId) return;
  if (isSpectatorMode) return;

  const roomId = currentRoomId;
  const myPid  = currentGameInfo.playerId;
  if (!myPid) return;

  const [cfgSnap, pSnap] = await Promise.all([
    db.ref(`rooms/${roomId}/gameConfig`).once("value"),
    db.ref(`rooms/${roomId}/players/${myPid}`).once("value"),
  ]);

  const cfg = cfgSnap.val() || {};
  const me  = pSnap.val() || {};
  const before = Number(me.point ?? 0);
  const after  = before - 1000;

  const reqId = genTransferRequestId();
  const reqPath = `rooms/${roomId}/transferRequests/${reqId}`;

  const updates = {};
  updates[`rooms/${roomId}/gameConfig/riichiStickCount`] = Number(cfg.riichiStickCount ?? 0) + 1;
  updates[`rooms/${roomId}/players/${myPid}/point`] = after;

  // potæ‰±ã„ï¼ˆä»•æ§˜ï¼‰
  updates[reqPath] = {
    fromPlayerId: myPid,
    toPlayerId: "pot",
    point: 1000,
    fromBefore: before,
    fromAfter: after,
    toBefore: null,
    toAfter: null,
    type: "riichi",
    status: "checked", // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ä¸è¦ãªã®ã§ç¢ºå®šæ‰±ã„
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    checkedAt: firebase.database.ServerValue.TIMESTAMP,
    checkedByPlayerId: myPid
  };

  await db.ref().update(updates);
}


// ===============================
// 014 ãƒªãƒ¼ãƒæ£’å—å–ï¼šè‡ªåˆ†point += æœ¬æ•°*1000 / ãƒªãƒ¼ãƒæ£’0
// ===============================
async function onRiichiTake(){
  if (!currentRoomId) return;
  if (isSpectatorMode) return;

  const roomId = currentRoomId;
  const myPid  = currentGameInfo.playerId;
  if (!myPid) return;

  const cfgRef = db.ref(`rooms/${roomId}/gameConfig/riichiStickCount`);
  const [cfgSnap, meSnap] = await Promise.all([
    cfgRef.once("value"),
    db.ref(`rooms/${roomId}/players/${myPid}/point`).once("value"),
  ]);

  const cnt = Number(cfgSnap.val() || 0);
  if (cnt <= 0) return;

  const before = Number(meSnap.val() || 0);
  const gain = cnt * 1000;
  const after = before + gain;

  const reqId = genTransferRequestId();
  const reqPath = `rooms/${roomId}/transferRequests/${reqId}`;

  const updates = {};
  updates[`rooms/${roomId}/players/${myPid}/point`] = after;
  updates[`rooms/${roomId}/gameConfig/riichiStickCount`] = 0;

  // pot â†’ è‡ªåˆ†ï¼ˆå—å–ï¼‰ã¨ã—ã¦å±¥æ­´ã«æ®‹ã™ï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ä¸è¦ï¼‰
  updates[reqPath] = {
    fromPlayerId: "pot",
    toPlayerId: myPid,
    point: gain,
    fromBefore: null,
    fromAfter: null,
    toBefore: before,
    toAfter: after,
    type: "riichi",        // å—å–ã‚‚riichiæ‰±ã„ã§OKï¼ˆä»•æ§˜ã«åˆã‚ã›ã‚‹ï¼‰
    status: "checked",
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    checkedAt: firebase.database.ServerValue.TIMESTAMP,
    checkedByPlayerId: myPid
  };

  await db.ref().update(updates);
}


async function checkReceive(){
  if (!currentRoomId) return;
  const roomId = currentRoomId;
  const myPid = currentGameInfo.playerId;
  if (!myPid) return;
  if (!currentReceiveReqId) return;

  const now = firebase.database.ServerValue.TIMESTAMP;

  await db.ref(`rooms/${roomId}/transferRequests/${currentReceiveReqId}`).update({
    status: "checked",
    checkedAt: now,
    checkedByPlayerId: myPid
  });

  closeReceiveSheet();
}


let historyCache = []; // è¡¨ç¤ºç”¨ï¼ˆæ˜‡é †ï¼‰

function subscribeHistory(){
  if (!currentRoomId) return;
  if (historyUnsub) historyUnsub();

  const roomId = currentRoomId;
  const myPid = currentGameInfo.playerId; // è¦³æˆ¦ã¯nullã€è¦³æˆ¦æ™‚ã¯å±¥æ­´å‡ºã•ãªã„æƒ³å®šãªã‚‰return
  if (!myPid) return;

  const ref = db.ref(`rooms/${roomId}/transferRequests`);

  const handler = async (snap) => {
    const obj = snap.val();
    if (!obj) return;

    // è‡ªåˆ†ãŒé–¢ä¿‚ã‚ã‚‹ã‚‚ã®ã ã‘
    const involved = (obj.fromPlayerId === myPid || obj.toPlayerId === myPid);
    if (!involved) return;

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¸è¿½åŠ ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
    const id = snap.key;
    if (historyCache.some(x => x._id === id)) return;

    historyCache.push({ _id: id, ...obj });
    historyCache.sort((a,b) => Number(a.createdAt||0) - Number(b.createdAt||0));

    // è¡¨ç¤ºæ›´æ–°
    const eSnap = await db.ref(`systemConfig/entryPlayers`).once("value");
    const ep = eSnap.val() || {};
    renderHistoryList(ep);
  };

  ref.on("child_added", handler);
  historyUnsub = () => ref.off("child_added", handler);
}

const transferRequestType = {
  "payment": "æ”¯æ‰•", 
  "riichi": "ãƒªãƒ¼ãƒæ£’"
}

const transferRequestStatus = {
  "pending": "æœªç¢ºèª",
  "checked": "ç¢ºèªæ¸ˆ"
} 

// å±¥æ­´è³¼èª­
function renderHistoryList(entryPlayers){
  if (!historyList) return;

  const nameOf = (pid) => {
    if (!pid) return "-";
    if (pid === "pot") return "å ´";
    return entryPlayers?.[pid]?.name ?? pid;
  };

  const fmtTime = (ts) => {
    const t = Number(ts || 0);
    if (!t) return "-";
    const d = new Date(t);
    const pad = (n)=>String(n).padStart(2,"0");
    return `${pad(d.getMonth()+1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  };

  historyList.innerHTML = "";

  for (const h of historyCache){

    const type = transferRequestType[h.type] || "-";
    const status = transferRequestStatus[h.status] || "";

    // ---- ã‚¿ã‚¤ãƒˆãƒ«è¡¨ç¤º ----
    let badge = type;
    if (type === transferRequestType["payment"]) {
      badge = `${type} / ${status}`;
    }

    const from = nameOf(h.fromPlayerId);
    const to   = nameOf(h.toPlayerId);

    // ---- åå‰è¡Œ ----
    const whoLine =
      h.fromPlayerId === "pot"
        ? `å ´ â†’ ${to}`
        : `${from} â†’ ${to}`;

    const item = document.createElement("div");
    item.className = "historyItem";

    item.innerHTML = `
      <div class="historyTop">
        <div>${fmtTime(h.createdAt)}</div>
        <div class="historyBadge">${badge}</div>
      </div>

      <div class="historyMain">
        <div class="historyWho">${whoLine}</div>
        <div class="historyPoint">${Number(h.point ?? 0)}</div>
      </div>

      <div class="historyMeta">
        <div>${from}: ${h.fromPlayerId === "pot" ? "å ´" : (h.fromBefore ?? "-")} â†’ ${h.fromAfter ?? "-"}</div>
        <div>${to}: ${h.toBefore ?? "-"} â†’ ${h.toAfter ?? "-"}</div>
      </div>
    `;

    historyList.appendChild(item);
  }

  if (historyCache.length === 0){
    const div = document.createElement("div");
    div.style.opacity = ".8";
    div.textContent = "å±¥æ­´ãŒã‚ã‚Šã¾ã›ã‚“ã€‚";
    historyList.appendChild(div);
  }
}


function setYakitoriImg(elId, flg){
  const el = document.getElementById(elId);
  if (!el) return;

  // true=on / false=off
  const src = flg ? "image/yakitori_on.png" : "image/yakitori_off.png";

  // æ¯å›ä¸Šæ›¸ãï¼ˆç¢ºå®Ÿã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åæ˜ ï¼‰
  if (el.src.endsWith(src) === false) el.src = src;
  else el.src = src; // â†ã“ã“ã‚’æ®‹ã™ã¨ã€Œå¸¸ã«ä¸Šæ›¸ãã€ã§ç¢ºå®Ÿï¼ˆå¥½ã¿ã§ï¼‰
}

function flipYakitoriBtn(btnId, nextFlg) {
  const btn = document.getElementById(btnId);
  if (!btn) return;

  const img = btn.querySelector(".yakitoriBtnImg");
  if (!img) return;

  // å¤šé‡ã‚¯ãƒªãƒƒã‚¯å¯¾ç­–
  if (btn.dataset.animating === "1") return;
  btn.dataset.animating = "1";

  const nextSrc = nextFlg ? "image/yakitori_on.png" : "image/yakitori_off.png";

  // ã²ã£ãã‚Šè¿”ã—é–‹å§‹
  btn.classList.add("is-flipping");

  // åŠå›è»¢ã‚ãŸã‚Šã§ç”»åƒã‚’å·®ã—æ›¿ãˆã‚‹ï¼ˆãã‚Œã£ã½ãè¦‹ãˆã‚‹ï¼‰
  setTimeout(() => {
    img.src = nextSrc;
  }, 130);

  // æˆ»ã™
  setTimeout(() => {
    btn.classList.remove("is-flipping");
    btn.dataset.animating = "0";
  }, 260);
}


// ===============================
// 019-021 é€ã‚Šå…ˆé¸æŠï¼ˆå¸¸ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ï¼‰
// ===============================
async function selectRecipient(rel){
  // rel: 'N'|'W'|'S'
  selectedRecipient = rel;
  sendAmountValue = 0;
  setText("sendAmount", "0");

  // ç¾åœ¨ã®ç›¸æ‰‹ã‚’è§£æ±ºã—ã¦ 015 ã«è¡¨ç¤º
  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const eSnap = await db.ref(`systemConfig/entryPlayers`).once("value");
  const players = pSnap.val() || {};
  const entryPlayers = eSnap.val() || {};

  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return;

  let targetPid = null;
  for (const [pid, p] of Object.entries(players)){
    if (pid === myPid) continue;
    const r = toRelative(my.direction, p.direction);
    if (r === rel) { targetPid = pid; break; }
  }

  setText("sendToName", targetPid ? (entryPlayers[targetPid]?.name ?? "ä¸æ˜") : "-");
  openTransferSheet();
}

// ===============================
// 022-026 é‡‘é¡åŠ ç®—ï¼ˆ015ãŒå‡ºã¦ã„ã‚‹å ´åˆã«æœ‰åŠ¹ã€ã¨ã„ã†ä»•æ§˜ã«è¿‘ã¥ã‘ã‚‹ï¼‰
// ===============================
function addAmount(amount){
  if (!selectedRecipient) return; // é€ã‚Šå…ˆæœªé¸æŠãªã‚‰ä½•ã‚‚ã—ãªã„
  sendAmountValue += amount;
  setText("sendAmount", String(sendAmountValue));
}

// ===============================
// 017 å–æ¶ˆï¼šé€ã‚Šå…ˆ/é‡‘é¡ãƒªã‚»ãƒƒãƒˆ
// ===============================
function cancelAmountValue(){
  sendAmountValue = 0;
  setText("sendAmount", "0");
}

// ===============================
// 017 å–æ¶ˆï¼šé€ã‚Šå…ˆ/é‡‘é¡ãƒªã‚»ãƒƒãƒˆ
// ===============================
function cancelTransfer(){
  selectedRecipient = null;
  sendAmountValue = 0;
  setText("sendToName", "-");
  setText("sendAmount", "0");
  closeTransferSheet();
}


// ===============================
// 018 ç¢ºå®šï¼šè‡ªåˆ†â†’ç›¸æ‰‹ã¸ point ç§»å‹•
// 015 ã®ç›¸æ‰‹ã« 016 ã®ç‚¹æ•°ã‚’ç§»å‹•
// ===============================
async function confirmTransfer(){
  if (!selectedRecipient) return;
  if (sendAmountValue <= 0) return;
  if (!currentRoomId) return;
  if (isSpectatorMode) return;

  const roomId = currentRoomId;

  // ç¾åœ¨ã® players ã¨ entryPlayers ã‚’å–å¾—ï¼ˆåå‰è¡¨ç¤ºç”¨ã¯åˆ¥é€”ã§OKã ãŒã€ã¾ãšç‚¹æ•°ç”¨ï¼‰
  const pSnap = await db.ref(`rooms/${roomId}/players`).once("value");
  const players = pSnap.val() || {};

  const myPid = currentGameInfo.playerId;
  const my = players[myPid];
  if (!my) return;

  // ç›¸æ‰‹pidè§£æ±ºï¼ˆrelã‹ã‚‰ï¼‰
  let targetPid = null;
  for (const [pid, p] of Object.entries(players)){
    if (pid === myPid) continue;
    const r = toRelative(my.direction, p.direction);
    if (r === selectedRecipient) { targetPid = pid; break; }
  }
  if (!targetPid) return;

  const fromBefore = Number(players?.[myPid]?.point ?? 0);
  const toBefore   = Number(players?.[targetPid]?.point ?? 0);
  const point      = Number(sendAmountValue);

  const fromAfter = fromBefore - point;
  const toAfter   = toBefore + point;

  // transferRequests ã«è¨˜éŒ²
  const reqId = genTransferRequestId();
  const reqPath = `rooms/${roomId}/transferRequests/${reqId}`;

  // multi-location updateï¼ˆtransactionç¦æ­¢ï¼‰
  const updates = {};
  updates[`rooms/${roomId}/players/${myPid}/point`] = fromAfter;
  updates[`rooms/${roomId}/players/${targetPid}/point`] = toAfter;

  // paymentã®å ´åˆï¼šå—ã‘å–ã‚Šå´ yakitoriFlg ã‚’ false ã«æ›´æ–°ï¼ˆä»•æ§˜ï¼‰
  updates[`rooms/${roomId}/players/${targetPid}/yakitoriFlg`] = false;

  updates[reqPath] = {
    fromPlayerId: myPid,
    toPlayerId: targetPid,
    point,
    fromBefore,
    fromAfter,
    toBefore,
    toAfter,
    type: "payment",
    status: "pending",
    createdAt: firebase.database.ServerValue.TIMESTAMP,
    checkedAt: null,
    checkedByPlayerId: null
  };

  await db.ref().update(updates);

  cancelTransfer(); // UIãƒªã‚»ãƒƒãƒˆ
}


// ãƒªãƒ¼ãƒæ£’è¡¨ç¤º
function renderRiichiSticks(count){
  const wrap = document.getElementById("riichiSticks");
  const num  = document.getElementById("riichiCount");
  if (!wrap || !num) return;

  const c = Number(count || 0);

  wrap.innerHTML = "";

  if (c <= 0){
    num.textContent = "0";
    return;
  }

  // æ£’ã¯å¸¸ã«1æœ¬ã ã‘
  const d = document.createElement("div");
  d.className = "stick";
  wrap.appendChild(d);

  // Ã—N è¡¨ç¤º
  num.textContent = `Ã—${c}`;
}


// ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆã‚’é–‹ã
function openTransferSheet(){
  transferOverlay.classList.remove("hidden");
  transferSheet.classList.remove("hidden");
  // ã‚¢ãƒ‹ãƒ¡ç”¨ã‚¯ãƒ©ã‚¹ã¯æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§ä»˜ã‘ã‚‹ï¼ˆåŠ¹ãï¼‰
  requestAnimationFrame(() => transferSheet.classList.add("is-open"));
}

// ãƒœãƒˆãƒ ã‚·ãƒ¼ãƒˆã‚’é–‰ã˜ã‚‹
function closeTransferSheet(){
  transferSheet.classList.remove("is-open");
  transferOverlay.classList.add("hidden");
  // transitionå¾Œã«hiddenã¸ï¼ˆé›‘ã§ã‚‚OKãªã‚‰setTimeoutï¼‰
  setTimeout(() => {
    transferSheet.classList.add("hidden");
  }, 230);
}

// è¦³æˆ¦æç”»é–¢æ•°
function renderSpectatorUI(players, gameConfig, entryPlayers) {
  // ä¸Šéƒ¨ï¼šæ±ã€åæ™‚è¨ˆå›ã‚Šï¼šå—ã€è¥¿ã€åŒ—
  // ç”»é¢ã®4æ ï¼ˆä¸Š/å·¦/ä¸­å¤®/ä¸‹ï¼‰ã¸å‰²ã‚Šå½“ã¦ï¼š
  // ä¸Š(nameN/pointN) = æ±
  // å·¦(nameW/pointW) = å—
  // ä¸­å¤®(myName/myPoint) = è¥¿
  // ä¸‹(nameS/pointS) = åŒ—

  const dirToPid = {};
  for (const [pid, p] of Object.entries(players || {})) {
    if (p?.direction) dirToPid[p.direction] = pid;
  }

  const nameOf = (pid) => pid ? (entryPlayers?.[pid]?.name ?? "ä¸æ˜") : "-";
  const pointOf = (pid) => pid ? String(Number(players?.[pid]?.point ?? 0)) : "-";

  const pidE = dirToPid["æ±"] || null;
  const pidS = dirToPid["å—"] || null;
  const pidW = dirToPid["è¥¿"] || null;
  const pidN = dirToPid["åŒ—"] || null;

  // ä¸Šï¼šæ±
  setText("nameN", nameOf(pidE));
  setText("pointN", pointOf(pidE));
  setText("diffN", "-");

  // å·¦ï¼šå—
  setText("nameW", nameOf(pidS));
  setText("pointW", pointOf(pidS));
  setText("diffW", "-");

  // ä¸­å¤®ï¼šè¥¿ï¼ˆè‡ªåˆ†æ ã‚’æµç”¨ï¼‰
  setText("myName", nameOf(pidW));
  setText("myPoint", pointOf(pidW));

  // ä¸‹ï¼šåŒ—
  setText("nameS", nameOf(pidN));
  setText("pointS", pointOf(pidN));
  setText("diffS", "-");

  // ãƒªãƒ¼ãƒæ£’
  setText("riichiCount", Number(gameConfig?.riichiStickCount ?? 0));

  // ãƒ¤ã‚­ãƒˆãƒªï¼ˆç©ºå¸­ã¯éè¡¨ç¤ºï¼‰
  const setYakitoriByPid = (imgId, pid) => {
    const el = document.getElementById(imgId);
    if (!el) return;

    if (!pid) {
      el.classList.add("is-hidden");
      return;
    }
    el.classList.remove("is-hidden");
    setYakitoriImg(imgId, players?.[pid]?.yakitoriFlg === true);
  };

  // ä¸Š=æ± => yakitoriN
  setYakitoriByPid("yakitoriN", pidE);
  // å·¦=å— => yakitoriW
  setYakitoriByPid("yakitoriW", pidS);
  // ä¸­å¤®=è¥¿ => yakitoriME
  setYakitoriByPid("yakitoriME", pidW);
  // ä¸‹=åŒ— => yakitoriS
  setYakitoriByPid("yakitoriS", pidN);

  // è¦³æˆ¦ã¯å¸­ã‚¿ãƒƒãƒ—ã§æ”¯æ‰•ãªã©ã‚’ã•ã›ãªã„ï¼ˆæ¯å›å¿µæŠ¼ã—ï¼‰
  const seatEls = [
    document.querySelector(".gs-north"),
    document.querySelector(".gs-west"),
    document.querySelector(".gs-south")
  ];
  for (const el of seatEls) {
    if (!el) continue;
    el.onclick = null;
    el.classList.remove("tapTarget");
  }

}

let currentReceiveReqId = null;

// å—å–ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— é–‹é–‰
function openReceiveSheet(){
  receiveOverlay.classList.remove("hidden");
  receiveSheet.classList.remove("hidden");
  requestAnimationFrame(() => receiveSheet.classList.add("is-open"));
}

function closeReceiveSheet(){
  receiveSheet.classList.remove("is-open");
  receiveOverlay.classList.add("hidden");
  setTimeout(() => receiveSheet.classList.add("hidden"), 230);
  currentReceiveReqId = null;
}

async function loadHistoryOnce(){
  if (!currentRoomId) return;

  const myPid = currentGameInfo.playerId;
  if (!myPid) return; // è¦³æˆ¦ã¯å±¥æ­´å‡ºã•ãªã„ãªã‚‰ã“ã“ã§return

  const [tSnap, eSnap] = await Promise.all([
    db.ref(`rooms/${currentRoomId}/transferRequests`).once("value"),
    db.ref(`systemConfig/entryPlayers`).once("value")
  ]);

  const all = tSnap.val() || {};
  const ep  = eSnap.val() || {};

  historyCache = Object.entries(all)
    .map(([id, v]) => ({ _id: id, ...(v || {}) }))
    .filter(h => h && (h.fromPlayerId === myPid || h.toPlayerId === myPid))
    .sort((a,b) => Number(a.createdAt||0) - Number(b.createdAt||0));

  renderHistoryList(ep);
}

// ===============================
// é€†è»¢æ¡ä»¶ï¼ˆBottom Sheetï¼‰
// ===============================
let gyakuLatestPlayers = null;
let gyakuLatestEntryPlayers = null;

// 023: è‡ªåˆ†ãŒ è¦ª/å­
let gyakuSelfRole = null; // "parent" | "child"

// å½¹è¡¨ç¤ºï¼ˆè¡¨ã®é †ï¼‰
const GY_LABELS = ["1å½¹","2å½¹","3å½¹","æº€è²«","è·³æº€","å€æº€","3å€æº€","å½¹æº€","Wå½¹æº€"];

// ç›´æ’ƒç‚¹æ•°è¡¨ç¤ºå¤‰æ›è¡¨ï¼ˆç”»åƒã«åˆã‚ã›ã‚‹ï¼‰
const RON_TABLE_PARENT = [
  { min:0,     max:3000,   point:1500,  label:GY_LABELS[0] }, // 1å½¹
  { min:3000,  max:6000,   point:3000,  label:GY_LABELS[1] }, // 2å½¹
  { min:6000,  max:12000,  point:6000,  label:GY_LABELS[2] }, // 3å½¹
  { min:12000, max:24000,  point:12000, label:GY_LABELS[3] }, // æº€è²«
  { min:24000, max:36000,  point:18000, label:GY_LABELS[4] }, // è·³æº€
  { min:36000, max:48000,  point:24000, label:GY_LABELS[5] }, // å€æº€
  { min:48000, max:72000,  point:36000, label:GY_LABELS[6] }, // 3å€æº€
  { min:72000, max:96000,  point:48000, label:GY_LABELS[7] }, // å½¹æº€
  { min:96000, max:192000, point:96000, label:GY_LABELS[8] }, // å½¹æº€
];

const RON_TABLE_CHILD = [
  { min:0,     max:2000,   point:1000,  label:GY_LABELS[0] },
  { min:2000,  max:4000,   point:2000,  label:GY_LABELS[1] },
  { min:4000,  max:8000,   point:4000,  label:GY_LABELS[2] },
  { min:8000,  max:16000,  point:8000,  label:GY_LABELS[3] },
  { min:16000, max:24000,  point:12000, label:GY_LABELS[4] },
  { min:24000, max:32000,  point:16000, label:GY_LABELS[5] },
  { min:32000, max:48000,  point:24000, label:GY_LABELS[6] },
  { min:48000, max:64000,  point:32000, label:GY_LABELS[7] },
  { min:64000, max:128000, point:64000, label:GY_LABELS[8] },
];

// ç›´æ’ƒç‚¹è¡¨ç¤ºå¤‰æ›è¡¨ï¼ˆç”»åƒã®è¡¨ï¼‰
// selfRole: "parent" or "child"
const GY_RON_TABLE = {
  parent: [
    { min: 0,     max: 3000,   point: 1500 },
    { min: 3000,  max: 6000,   point: 3000 },
    { min: 6000,  max: 12000,  point: 6000 },
    { min: 12000, max: 24000,  point: 12000 },
    { min: 24000, max: 36000,  point: 18000 },
    { min: 36000, max: 48000,  point: 24000 },
    { min: 48000, max: 72000,  point: 36000 },
    { min: 72000, max: 96000,  point: 48000 },
    { min: 96000, max: 192000, point: 96000 },
  ],
  child: [
    { min: 0,     max: 2000,   point: 1000 },
    { min: 2000,  max: 4000,   point: 2000 },
    { min: 4000,  max: 8000,   point: 4000 },
    { min: 8000,  max: 16000,  point: 8000 },
    { min: 16000, max: 24000,  point: 12000 },
    { min: 24000, max: 32000,  point: 16000 },
    { min: 32000, max: 48000,  point: 24000 },
    { min: 48000, max: 64000,  point: 32000 },
    { min: 64000, max: 128000, point: 64000 },
  ],
};


// ãƒ„ãƒ¢ï¼šå¿…è¦ãªã€Œè‡ªåˆ†ã®å¢—åˆ†(selfGain)ã€ã¨ã€Œãƒˆãƒƒãƒ—ã®æ¸›åˆ†(topLoss)ã€ã‚’åˆ†ã‘ã‚‹
// row = {min,max,selfGain,topLoss,label}
const TSUMO_TABLES = {
  "4": {
    // è‡ªåˆ†=è¦ª / ç›¸æ‰‹(ãƒˆãƒƒãƒ—)=å­
    parent_vs_child: [
      { min:0,     max:2000,   selfGain:1500, topLoss:500,  label:GY_LABELS[0] },
      { min:2000,  max:4000,   selfGain:3000, topLoss:1000, label:GY_LABELS[1] },
      { min:4000,  max:8000,   selfGain:6000, topLoss:2000, label:GY_LABELS[2] },
      { min:8000,  max:16000,  selfGain:12000,topLoss:4000, label:GY_LABELS[3] },
      { min:16000, max:24000,  selfGain:18000,topLoss:6000, label:GY_LABELS[4] },
      { min:24000, max:32000,  selfGain:24000,topLoss:8000, label:GY_LABELS[5] },
      { min:32000, max:48000,  selfGain:36000,topLoss:12000,label:GY_LABELS[6] },
      { min:48000, max:64000,  selfGain:48000,topLoss:16000,label:GY_LABELS[7] },
      { min:64000, max:128000, selfGain:96000,topLoss:32000,label:GY_LABELS[8] },
    ],
    // è‡ªåˆ†=å­ / ç›¸æ‰‹(ãƒˆãƒƒãƒ—)=è¦ª
    child_vs_parent: [
      { min:0,     max:1600,   selfGain:1100, topLoss:500,  label:GY_LABELS[0] },
      { min:1600,  max:3000,   selfGain:2000, topLoss:1000, label:GY_LABELS[1] },
      { min:3000,  max:6000,   selfGain:4000, topLoss:2000, label:GY_LABELS[2] },
      { min:6000,  max:12000,  selfGain:8000, topLoss:4000, label:GY_LABELS[3] },
      { min:12000, max:18000,  selfGain:12000,topLoss:6000, label:GY_LABELS[4] },
      { min:18000, max:24000,  selfGain:16000,topLoss:8000, label:GY_LABELS[5] },
      { min:24000, max:36000,  selfGain:24000,topLoss:12000,label:GY_LABELS[6] },
      { min:36000, max:54000,  selfGain:32000,topLoss:16000,label:GY_LABELS[7] },
      { min:54000, max:96000,  selfGain:64000,topLoss:32000,label:GY_LABELS[8] },
    ],
    // è‡ªåˆ†=å­ / ç›¸æ‰‹(ãƒˆãƒƒãƒ—)=å­
    child_vs_child: [
      { min:0,     max:1400,   selfGain:1000, topLoss:300,  label:GY_LABELS[0] },
      { min:1400,  max:2500,   selfGain:2000, topLoss:500,  label:GY_LABELS[1] },
      { min:2500,  max:5000,   selfGain:4000, topLoss:1000, label:GY_LABELS[2] },
      { min:5000,  max:10000,  selfGain:8000, topLoss:2000, label:GY_LABELS[3] },
      { min:10000, max:15000,  selfGain:12000,topLoss:3000, label:GY_LABELS[4] },
      { min:15000, max:20000,  selfGain:16000,topLoss:4000, label:GY_LABELS[5] },
      { min:20000, max:30000,  selfGain:24000,topLoss:6000, label:GY_LABELS[6] },
      { min:30000, max:45000,  selfGain:32000,topLoss:9000, label:GY_LABELS[7] },
      { min:45000, max:80000,  selfGain:64000,topLoss:16000,label:GY_LABELS[8] },
    ],
  },

  "3": {
    // è‡ªåˆ†=è¦ª / ç›¸æ‰‹(ãƒˆãƒƒãƒ—)=å­
    parent_vs_child: [
      { min:0,     max:2400,   selfGain:1600, topLoss:800,  label:GY_LABELS[0] },
      { min:2400,  max:4500,   selfGain:3000, topLoss:1500, label:GY_LABELS[1] },
      { min:4500,  max:9000,   selfGain:6000, topLoss:3000, label:GY_LABELS[2] },
      { min:9000,  max:18000,  selfGain:12000,topLoss:6000, label:GY_LABELS[3] },
      { min:18000, max:27000,  selfGain:18000,topLoss:9000, label:GY_LABELS[4] },
      { min:27000, max:36000,  selfGain:24000,topLoss:12000,label:GY_LABELS[5] },
      { min:36000, max:54000,  selfGain:36000,topLoss:18000,label:GY_LABELS[6] },
      { min:54000, max:72000,  selfGain:48000,topLoss:24000,label:GY_LABELS[7] },
      { min:72000, max:144000, selfGain:96000,topLoss:48000,label:GY_LABELS[8] },
    ],
    // è‡ªåˆ†=å­ / ç›¸æ‰‹(ãƒˆãƒƒãƒ—)=è¦ª
    child_vs_parent: [
      { min:0,     max:1900,   selfGain:1100, topLoss:700,  label:GY_LABELS[0] },
      { min:1900,  max:3400,   selfGain:2000, topLoss:1300, label:GY_LABELS[1] },
      { min:3400,  max:6500,   selfGain:4000, topLoss:2500, label:GY_LABELS[2] },
      { min:6500,  max:13000,  selfGain:8000, topLoss:5000, label:GY_LABELS[3] },
      { min:13000, max:19500,  selfGain:12000,topLoss:7500, label:GY_LABELS[4] },
      { min:19500, max:26000,  selfGain:16000,topLoss:10000,label:GY_LABELS[5] },
      { min:26000, max:39000,  selfGain:24000,topLoss:15000,label:GY_LABELS[6] },
      { min:39000, max:52000,  selfGain:32000,topLoss:20000,label:GY_LABELS[7] },
      { min:52000, max:104000, selfGain:64000,topLoss:40000,label:GY_LABELS[8] },
    ],
    // è‡ªåˆ†=å­ / ç›¸æ‰‹(ãƒˆãƒƒãƒ—)=å­
    child_vs_child: [
      { min:0,     max:1700,   selfGain:1100, topLoss:500,  label:GY_LABELS[0] },
      { min:1700,  max:2900,   selfGain:2000, topLoss:800,  label:GY_LABELS[1] },
      { min:2900,  max:5500,   selfGain:4000, topLoss:1500, label:GY_LABELS[2] },
      { min:5500,  max:11000,  selfGain:8000, topLoss:3000, label:GY_LABELS[3] },
      { min:11000, max:16500,  selfGain:12000,topLoss:4500, label:GY_LABELS[4] },
      { min:16500, max:22000,  selfGain:16000,topLoss:6000, label:GY_LABELS[5] },
      { min:22000, max:33000,  selfGain:24000,topLoss:9000, label:GY_LABELS[6] },
      { min:33000, max:44000,  selfGain:32000,topLoss:12000,label:GY_LABELS[7] },
      { min:44000, max:88000,  selfGain:64000,topLoss:24000,label:GY_LABELS[8] },
    ],
  },

  // 3r4 ã¯è¡¨è‡ªä½“ã¯ 3 ã¨åŒã˜è¨ˆç®—ã§ã¾ãšOKï¼ˆæŠœã‘ç•ªå¯¾å¿œã‚’å…¥ã‚Œã‚‹ãªã‚‰åˆ¥é€”ã‚­ãƒ¼è¿½åŠ ï¼‰
  "3r4": null,
};

// 3r4ï¼ˆ3éº»4äººå›ã—ï¼‰å°‚ç”¨ï¼šæŠœã‘ç•ªï¼ˆç›¸æ‰‹æ”¯æ‰•ã„0ï¼‰ã®ãƒ„ãƒ¢å¤‰æ›è¡¨
// 023ã®é¸æŠãŒã€Œè¦ªã€ã®ã¨ãã®æŠœã‘ç•ªåˆ—
const TSUMO_NUKE_023_OYA = [
  { min: 0,     max: 1600,  me: 1600  },
  { min: 1600,  max: 3000,  me: 3000  },
  { min: 3000,  max: 6000,  me: 6000  },
  { min: 6000,  max: 12000, me: 12000 },
  { min: 12000, max: 18000, me: 18000 },
  { min: 18000, max: 24000, me: 24000 },
  { min: 24000, max: 36000, me: 36000 },
  { min: 36000, max: 48000, me: 48000 },
  { min: 48000, max: 96000, me: 96000 },
];

// 023ã®é¸æŠãŒã€Œå­ã€ã®ã¨ãã®æŠœã‘ç•ªåˆ—
const TSUMO_NUKE_023_KO = [
  { min: 0,     max: 1100,  me: 1100  },
  { min: 1100,  max: 2000,  me: 2000  },
  { min: 2000,  max: 4000,  me: 4000  },
  { min: 4000,  max: 8000,  me: 8000  },
  { min: 8000,  max: 12000, me: 12000 },
  { min: 12000, max: 16000, me: 16000 },
  { min: 16000, max: 24000, me: 24000 },
  { min: 24000, max: 32000, me: 32000 },
  { min: 32000, max: 64000, me: 64000 },
];

// label ä»˜ä¸ï¼ˆâ˜…å¿…ãšä¸¡æ–¹ã® const ã®å¾Œï¼‰
[TSUMO_NUKE_023_OYA, TSUMO_NUKE_023_KO].forEach(tbl => {
  tbl.forEach((r, i) => { r.label = GY_LABELS[i]; });
});

function formatNeed(label, point){
  const p = Number(point || 0);
  if (!label) return String(p);
  return `${label}ï¼ˆ${p}ï¼‰`;
}

function lookupRonPoint(diffAbs, selfRole) {
  const rows = GY_RON_TABLE[selfRole] || GY_RON_TABLE.child;
  for (const r of rows) {
    // è¡¨ã®æ¡ä»¶ï¼šmin <= diff < max
    if (diffAbs >= r.min && diffAbs < r.max) return r.point;
  }
  // ç¯„å›²å¤–ã¯æœ€å¾Œã®pointæ‰±ã„ï¼ˆä¿é™ºï¼‰
  return rows[rows.length - 1].point;
}

function lookupRonRow(diffAbs, selfRole) {
  const rows = (selfRole === "parent") ? RON_TABLE_PARENT : RON_TABLE_CHILD;
  for (const r of rows) {
    if (diffAbs >= r.min && diffAbs < r.max) return r; // {point,label}
  }
  return rows[rows.length - 1];
}

function setText(id, v){
  const el = document.getElementById(id);
  if (el) el.textContent = String(v);
}

function showEl(id, show){
  const el = document.getElementById(id);
  if (!el) return;
  el.classList.toggle("hidden", !show);
}

// æŠœã‘ç•ªï¼ˆ3éº»4äººå›ã—ï¼‰ã®ã€Œç›´æ’ƒï¼ˆãƒ­ãƒ³ï¼‰ã€è¡¨ç¤º
// å‰æï¼šplayers ã¯ {pid: {name, point}} ã¿ãŸã„ãªæ§‹é€ ã‚’æƒ³å®š
function renderRonNuke_3r4({
  rule,
  selfRole,     // "parent" or "child"
  mePid,
  topPid,
  diffAbs,      // |topPoint - mePoint|
  players
}){
  const enable = (rule === "3r4");
  showEl("gyRonNuke", enable);
  if (!enable) return;

  // ãƒˆãƒƒãƒ—ä»¥å¤–ï¼†è‡ªåˆ†ä»¥å¤–ã®2äºº
  const otherPids = Object.keys(players || {})
    .filter(pid => pid !== mePid && pid !== topPid)
    .slice(0, 2);

  // ä¸‡ä¸€2äººå–ã‚Œãªã„ã‚±ãƒ¼ã‚¹ã¯éè¡¨ç¤º
  if (otherPids.length < 2) {
    showEl("gyRonNuke", false);
    return;
  }

  const me  = players[mePid];
  const top = players[topPid];
  const o1  = players[otherPids[0]];
  const o2  = players[otherPids[1]];

  // é€šå¸¸ç›´æ’ƒã®å¿…è¦ç‚¹ï¼ˆè¡¨ã®pointåˆ—: 1500/3000/... or 1000/2000/...ï¼‰
  const baseRow  = lookupRonRow(diffAbs * 2, selfRole);
  const baseNeed = baseRow.point;

  // â˜…é»„è‰²åˆ—ï¼ˆãƒˆãƒƒãƒ—ä»¥å¤– pointï¼‰ã¯é€šå¸¸ç›´æ’ƒ(point)ã®2å€
  const nukeNeed = baseNeed;

  // â˜…æŠœã‘ç•ªãƒ­ãƒ³ï¼šãƒˆãƒƒãƒ—ã¯Â±0ã€ãƒˆãƒƒãƒ—ä»¥å¤–2äººãŒãã‚Œãã‚Œ nukeNeed ã‚’æ”¯æ‰•ã†
  const payEach = nukeNeed;

  const meBefore  = Number(me?.point ?? 0);
  const topBefore = Number(top?.point ?? 0);
  const o1Before  = Number(o1?.point ?? 0);
  const o2Before  = Number(o2?.point ?? 0);

  const meAfter  = meBefore + payEach;
  const topAfter = topBefore;              // ãƒˆãƒƒãƒ—ã¯Â±0
  const o1After  = o1Before - payEach;
  const o2After  = o2Before - payEach;

  // è¡¨ç¤ºï¼ˆå¿…è¦ç‚¹ã¯é»„è‰²åˆ—ã®å€¤ã‚’å‡ºã™ï¼‰
  setText("gyRonNeed_nuke", diffAbs ? formatNeed(baseRow.label, nukeNeed) : "-");

  setText("gyRonMeBefore_nuke", diffAbs ? meBefore : "-");
  setText("gyRonMeAfter_nuke",  diffAbs ? meAfter : "-");
  setText("gyRonMeDelta_nuke",  diffAbs ? `ï¼ˆ+${payEach}ï¼‰` : "-");

  setText("gyRonTopName", diffAbs ? `${top?.name}` ?? "TOP" : "-");
  setText("gyRonTopBefore_nuke", diffAbs ? topBefore : "-");
  setText("gyRonTopAfter_nuke",  diffAbs ? topAfter : "-");
  setText("gyRonTopDelta_nuke",  diffAbs ? "ï¼ˆÂ±0ï¼‰" : "-");

  setText("gyRonOther1Name", o1?.name ?? "ãã®ä»–â‘ ");
  setText("gyRonOther2Name", o2?.name ?? "ãã®ä»–â‘¡");

  setText("gyRonOther1Before", diffAbs ? o1Before : "-");
  setText("gyRonOther1After",  diffAbs ? o1After : "-");
  setText("gyRonOther1Delta",  diffAbs ? `ï¼ˆ-${payEach}ï¼‰` : "-");

  setText("gyRonOther2Before", diffAbs ? o2Before : "-");
  setText("gyRonOther2After",  diffAbs ? o2After : "-");
  setText("gyRonOther2Delta",  diffAbs ? `ï¼ˆ-${payEach}ï¼‰` : "-");
}




function lookupNuke(diff, is023OyaSelected){
  const table = is023OyaSelected ? TSUMO_NUKE_023_OYA : TSUMO_NUKE_023_KO;
  const row = table.find(r => diff >= r.min && diff < r.max) || table[table.length - 1];
  return { label: row.label, me: row.me, opp: 0 };
}


function isParentByDirection(dir){
  return dir === "æ±";
}

function findNeedRow(diff, table){
  const d = Math.max(0, Number(diff || 0));
  for (const r of table){
    if (d >= r.min && d < r.max) return r;
  }
  return table[table.length - 1];
}

function findNeed(diff, table){
  const d = Math.max(0, Number(diff || 0));
  for (const r of table){
    if (d >= r.min && d < r.max) return r;
  }
  // ä¸Šé™è¶…ãˆã¯æœ€å¾Œã®è¡Œ
  return table[table.length - 1];
}

function getMyRoleDefault(){
  // æ—¢å®šï¼šè‡ªåˆ†ã® direction ãŒ æ± ãªã‚‰è¦ªã€ãã‚Œä»¥å¤–ã¯å­
  return (currentGameInfo?.direction === "æ±") ? "parent" : "child";
}

function setGyakuRadio(role){
  const rs = document.querySelectorAll('input[name="gySelfRole"]');
  rs.forEach(r => r.checked = (r.value === role));
}

function hookGyakuRadioOnce(){
  const rs = document.querySelectorAll('input[name="gySelfRole"]');
  rs.forEach(r => {
    // ä½•å›openã—ã¦ã‚‚äºŒé‡ç™»éŒ²ã—ã«ãã„ã‚ˆã†ã«ä¸€åº¦æ¶ˆã™ï¼ˆç°¡æ˜“ï¼‰
    r.onchange = null;
    r.onchange = () => {
      gyakuSelfRole = r.value;
      if (gyakuLatestPlayers && gyakuLatestEntryPlayers) {
        renderGyakuSheet(gyakuLatestPlayers, gyakuLatestEntryPlayers);
      }
    };
  });
}

// é€†è»¢
function openGyakuSheet(){
  if (isSpectatorMode) return; // è¦³æˆ¦ã¯ä¸å¯ã«ã™ã‚‹ãªã‚‰ï¼ˆå¿…è¦ãªã‚‰å¤–ã—ã¦OKï¼‰

  gyakuOverlay.classList.remove("hidden");
  gyakuSheet.classList.remove("hidden");
  requestAnimationFrame(() => gyakuSheet.classList.add("is-open"));

  // åˆå›ã ã‘ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚»ãƒƒãƒˆ
  if (!gyakuSelfRole) gyakuSelfRole = getMyRoleDefault();
  setGyakuRadio(gyakuSelfRole);
  hookGyakuRadioOnce();

  subscribeGyakuSheet();
}

// é€†è»¢
function closeGyakuSheet(){
  gyakuSheet.classList.remove("is-open");
  gyakuOverlay.classList.add("hidden");
  setTimeout(() => gyakuSheet.classList.add("hidden"), 230);

  if (gyakuUnsub) { gyakuUnsub(); gyakuUnsub = null; }
}

// é€†è»¢
function subscribeGyakuSheet(){
  if (!currentRoomId) return;

  // æ—¢å­˜è§£é™¤
  if (gyakuUnsub) gyakuUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      entryRef.once("value"),
    ]);
    gyakuLatestPlayers = pSnap.val() || {};
    gyakuLatestEntryPlayers = eSnap.val() || {};
    renderGyakuSheet(gyakuLatestPlayers, gyakuLatestEntryPlayers);
  };

  playersRef.on("value", handler);
  gyakuUnsub = () => playersRef.off("value", handler);

  handler();
  document.getElementById("gyakuBody")?.scrollTo({ top: 0 });
}

// é€†è»¢
function renderGyakuSheet(players, entryPlayers){
  const myPid = currentGameInfo?.playerId;
  if (!myPid || !players?.[myPid]) return;

  const myPoint = Number(players[myPid]?.point ?? 0);

  // ãƒˆãƒƒãƒ—ï¼ˆå‚åŠ è€…ã®æœ€å¤§pointï¼‰
  let topPid = myPid;
  let topPoint = myPoint;
  for (const [pid, p] of Object.entries(players || {})){
    if (!p?.direction) continue;
    const pt = Number(p.point ?? 0);
    if (pt > topPoint){
      topPoint = pt;
      topPid = pid;
    }
  }

  // å·®åˆ†ï¼ˆãƒˆãƒƒãƒ— - è‡ªåˆ†ï¼‰
  const diffRaw = Number(topPoint - myPoint);
  const diff = Math.max(0, diffRaw);

  // 023: è‡ªåˆ†ã®ç«‹å ´ï¼ˆãƒ©ã‚¸ã‚ªã‹ã‚‰ç›´æ¥æ‹¾ã†ï¼‰
  const selfRole = document.querySelector('input[name="gySelfRole"]:checked')?.value || "child";
  gyakuSelfRole = selfRole; // æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã¨ã‚‚æ•´åˆã•ã›ã‚‹ï¼ˆä¿é™ºï¼‰
  const isSelfParent = (selfRole === "parent");

  // ---------- ç›´æ’ƒï¼ˆãƒ­ãƒ³ï¼‰ ----------
  const ronRow = (topPid === myPid)
    ? { point: 0, label: "ãƒˆãƒƒãƒ—" }
    : findNeed(diff, isSelfParent ? RON_TABLE_PARENT : RON_TABLE_CHILD);

  // å·®åˆ†è¡¨ç¤ºï¼ˆå½¹å + ç‚¹æ•°ï¼‰
  setText("gyName", `${String(entryPlayers[topPid].name)}ï¼ˆ${topPoint}ï¼‰`);
  setText("gyMyName", `${String(entryPlayers[myPid].name)}ï¼ˆ${myPoint}ï¼‰`);
  setText("gyDiff", String(diff*-1));


  // ç›´æ’ƒè¡¨ç¤º
  const ronP = Number(ronRow.point ?? 0);
  setText("gyRonNeed", diff ? formatNeed(ronRow?.label, ronP) : "-");

  setText("gyRonMeBefore", diff ? String(myPoint) : "-");
  setText("gyRonMeAfter",  diff ? String(myPoint + ronP) : "-");
  setText("gyRonMeDelta",  diff ? `ï¼ˆ+${ronP}ï¼‰` : "-");

  setText("gyRonTopBefore", diff ? String(topPoint) : "-");
  setText("gyRonTopAfter",  diff ? String(topPoint - ronP) : "-");
  setText("gyRonTopDelta",  diff ? `ï¼ˆ-${ronP}ï¼‰` : "-");

  // ---------- â˜…3éº»4äººå›ã—ï¼šæŠœã‘ç•ªï¼ˆãƒ­ãƒ³ï¼‰ã‚’å†è¨ˆç®—ã—ã¦æç”» ----------
  // renderRonNuke_3r4 ã¯ players[pid].name ã‚’å‚ç…§ã™ã‚‹ã®ã§ã€nameä»˜ãã®mapã‚’ä½œã£ã¦æ¸¡ã™
  const playersForRonNuke = {};
  for (const [pid, p] of Object.entries(players || {})) {
    if (!p?.direction) continue; // å‚åŠ è€…ã®ã¿ï¼ˆè¦³æˆ¦ã‚„ç©ºå¸­ã‚’é™¤å¤–ï¼‰
    playersForRonNuke[pid] = {
      name: entryPlayers?.[pid]?.name ?? pid,
      point: Number(p.point ?? 0),
    };
  }

  renderRonNuke_3r4({
    rule: currentRule,                      // rooms/{roomId}/gameConfig/rule ã‚’ currentRule ã«å…¥ã‚Œã¦ã‚‹å‰æ
    selfRole,                               // "parent" or "child"
    mePid: myPid,
    topPid,
    diffAbs: Math.abs(topPoint - myPoint),  // diffã§ã‚‚OK
    players: playersForRonNuke
  });


  // ---------- ãƒ„ãƒ¢ï¼ˆ2ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰ ----------
  if (topPid === myPid) {
    renderGyakuTsumoBlocks(selfRole,
      { need:"-", meBefore:"-", meAfter:"-", meDelta:"ï¼ˆ+0ï¼‰", topBefore:"-", topAfter:"-", topDelta:"ï¼ˆ-0ï¼‰" },
      { need:"-", meBefore:"-", meAfter:"-", meDelta:"ï¼ˆ+0ï¼‰", topBefore:"-", topAfter:"-", topDelta:"ï¼ˆ-0ï¼‰" }
    );
    renderGyakuNuke(false, diff, selfRole, myPoint, topPoint); // 3r4ä»¥å¤–ã¯éš ã™
    return;
  }

  const ruleKey = (currentRule === "3r4") ? "3" : String(currentRule || "3");
  const tables = TSUMO_TABLES[ruleKey];
  if (!tables) {
    renderGyakuTsumoBlocks(selfRole,
      { need:"-", meBefore:"-", meAfter:"-", meDelta:"ï¼ˆ+0ï¼‰", topBefore:"-", topAfter:"-", topDelta:"ï¼ˆ-0ï¼‰" },
      { need:"-", meBefore:"-", meAfter:"-", meDelta:"ï¼ˆ+0ï¼‰", topBefore:"-", topAfter:"-", topDelta:"ï¼ˆ-0ï¼‰" }
    );
    renderGyakuNuke(false, diff, selfRole, myPoint, topPoint);
    return;
  }

  let patVsParent = null;
  let patVsChild  = null;

  if (selfRole === "parent") {
    // è‡ªåˆ†=è¦ªï¼šç›¸æ‰‹(ãƒˆãƒƒãƒ—)ã¯å­ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¿
    const row = findNeedRow(diff, tables.parent_vs_child);
    patVsChild = {
      need: `${row.label}ï¼ˆ+${row.selfGain} / ãƒˆãƒƒãƒ—-${row.topLoss}ï¼‰`,
      meBefore: String(myPoint),
      meAfter:  String(myPoint + row.selfGain),
      meDelta:  `ï¼ˆ+${row.selfGain}ï¼‰`,
      topBefore:String(topPoint),
      topAfter: String(topPoint - row.topLoss),
      topDelta: `ï¼ˆ-${row.topLoss}ï¼‰`,
    };
  } else {
    // è‡ªåˆ†=å­ï¼šç›¸æ‰‹ãŒè¦ª/å­ã§ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’å¤‰ãˆã‚‹ï¼ˆä¸¡æ–¹å‡ºã™ï¼‰
    const rowParent = findNeedRow(diff, tables.child_vs_parent);
    const rowChild  = findNeedRow(diff, tables.child_vs_child);

    patVsParent = {
      need: `${rowParent.label}ï¼ˆ+${rowParent.selfGain} / ãƒˆãƒƒãƒ—-${rowParent.topLoss}ï¼‰`,
      meBefore: String(myPoint),
      meAfter:  String(myPoint + rowParent.selfGain),
      meDelta:  `ï¼ˆ+${rowParent.selfGain}ï¼‰`,
      topBefore:String(topPoint),
      topAfter: String(topPoint - rowParent.topLoss),
      topDelta: `ï¼ˆ-${rowParent.topLoss}ï¼‰`,
    };
    patVsChild = {
      need: `${rowChild.label}ï¼ˆ+${rowChild.selfGain} / ãƒˆãƒƒãƒ—-${rowChild.topLoss}ï¼‰`,
      meBefore: String(myPoint),
      meAfter:  String(myPoint + rowChild.selfGain),
      meDelta:  `ï¼ˆ+${rowChild.selfGain}ï¼‰`,
      topBefore:String(topPoint),
      topAfter: String(topPoint - rowChild.topLoss),
      topDelta: `ï¼ˆ-${rowChild.topLoss}ï¼‰`,
    };
  }



  renderGyakuTsumoBlocks(selfRole, patVsParent, patVsChild);

  // 3r4 æŠœã‘ç•ªï¼ˆå¿…è¦ãªã‚‰è¡¨ç¤ºï¼‰
  renderGyakuNuke(currentRule === "3r4", diff, selfRole, myPoint, topPoint);
}



// é€†è»¢
function renderGyakuTsumoBlocks(selfRole, patVsParent, patVsChild) {
  const boxParent = document.getElementById("gyTsumoVsParent");
  const boxChild  = document.getElementById("gyTsumoVsChild");

  if (selfRole === "parent") {
    boxParent?.classList.add("hidden");
    boxChild?.classList.remove("hidden");

    setText("gyTsumoNeed_vsChild", patVsChild?.need ?? "-");
    setText("gyTsumoMeBefore_vsChild", patVsChild?.meBefore ?? "-");
    setText("gyTsumoMeAfter_vsChild",  patVsChild?.meAfter ?? "-");
    setText("gyTsumoMeDelta_vsChild",  patVsChild?.meDelta ?? "ï¼ˆ+0ï¼‰");

    setText("gyTsumoTopBefore_vsChild",patVsChild?.topBefore ?? "-");
    setText("gyTsumoTopAfter_vsChild", patVsChild?.topAfter ?? "-");
    setText("gyTsumoTopDelta_vsChild", patVsChild?.topDelta ?? "ï¼ˆ-0ï¼‰");
    return;
  }

  // è‡ªåˆ†=å­ï¼šè¦ª/å­ã®2ãƒ‘ã‚¿ãƒ¼ãƒ³è¡¨ç¤º
  boxParent?.classList.remove("hidden");
  boxChild?.classList.remove("hidden");

  // vs è¦ª
  setText("gyTsumoNeed_vsParent", patVsParent?.need ?? "-");
  setText("gyTsumoMeBefore_vsParent", patVsParent?.meBefore ?? "-");
  setText("gyTsumoMeAfter_vsParent",  patVsParent?.meAfter ?? "-");
  setText("gyTsumoMeDelta_vsParent",  patVsParent?.meDelta ?? "ï¼ˆ+0ï¼‰");

  setText("gyTsumoTopBefore_vsParent",patVsParent?.topBefore ?? "-");
  setText("gyTsumoTopAfter_vsParent", patVsParent?.topAfter ?? "-");
  setText("gyTsumoTopDelta_vsParent", patVsParent?.topDelta ?? "ï¼ˆ-0ï¼‰");

  // vs å­
  setText("gyTsumoNeed_vsChild", patVsChild?.need ?? "-");
  setText("gyTsumoMeBefore_vsChild", patVsChild?.meBefore ?? "-");
  setText("gyTsumoMeAfter_vsChild",  patVsChild?.meAfter ?? "-");
  setText("gyTsumoMeDelta_vsChild",  patVsChild?.meDelta ?? "ï¼ˆ+0ï¼‰");

  setText("gyTsumoTopBefore_vsChild",patVsChild?.topBefore ?? "-");
  setText("gyTsumoTopAfter_vsChild", patVsChild?.topAfter ?? "-");
  setText("gyTsumoTopDelta_vsChild", patVsChild?.topDelta ?? "ï¼ˆ-0ï¼‰");
}

function renderGyakuNuke(enabled, diff, selfRole, myPoint, topPoint){
  const box = document.getElementById("gyTsumoNuke");
  if (!box) return;

  if (!enabled) {
    box.classList.add("hidden");
    return;
  }

  box.classList.remove("hidden");

  const is023OyaSelected = (selfRole === "parent");
  const nuke = lookupNuke(diff, is023OyaSelected); // { me: xxx, opp:0 }

  setText("gyTsumoNeed_nuke", `${nuke.label}ï¼ˆ+${nuke.me} / ãƒˆãƒƒãƒ—-0ï¼‰`);

  setText("gyTsumoMeBefore_nuke", String(myPoint));
  setText("gyTsumoMeAfter_nuke",  String(myPoint + Number(nuke.me)));
  setText("gyTsumoMeDelta_nuke",  `ï¼ˆ+${nuke.me}ï¼‰`);

  setText("gyTsumoTopBefore_nuke", String(topPoint));
  setText("gyTsumoTopAfter_nuke",  String(topPoint)); // ãƒˆãƒƒãƒ—æ¸›ã‚‰ãªã„
  setText("gyTsumoTopDelta_nuke",  `ï¼ˆ-0ï¼‰`);
}


// å±¥æ­´ã‚·ãƒ¼ãƒˆ è¡¨ç¤º
async function openHistorySheet(){
  historyOverlay.classList.remove("hidden");
  historySheet.classList.remove("hidden");
  requestAnimationFrame(() => historySheet.classList.add("is-open"));

  // â˜…è¿½åŠ ï¼šã¾ãšå…¨ä»¶è¡¨ç¤º â†’ ãã®å¾Œãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
  historyCache = [];
  await loadHistoryOnce();
  subscribeHistory();
}


// å±¥æ­´ã‚·ãƒ¼ãƒˆ éè¡¨ç¤º
function closeHistorySheet(){
  historySheet.classList.remove("is-open");
  historyOverlay.classList.add("hidden");
  setTimeout(() => historySheet.classList.add("hidden"), 230);
}

// ===============================
// å¯¾å±€çµ‚äº†ç”»é¢ç”¨ï¼šå±¥æ­´ï¼ˆå…¨ä»¶ / checkedAt æ˜‡é †ï¼‰
// ===============================
async function loadHistoryAllOnceSortedByCheckedAtAsc(){
  if (!currentRoomId) return;

  const [tSnap, eSnap] = await Promise.all([
    db.ref(`rooms/${currentRoomId}/transferRequests`).once("value"),
    db.ref(`systemConfig/entryPlayers`).once("value")
  ]);

  const all = tSnap.val() || {};
  const ep  = eSnap.val() || {};

  historyCache = Object.entries(all)
    .map(([id, v]) => ({ _id: id, ...(v || {}) }))
    // checkedAt æ˜‡é †ï¼ˆnull ã¯æœ€å¾Œã«å›ã™ï¼‰
    .sort((a,b) => {
      const aa = (a.checkedAt === null || a.checkedAt === undefined) ? Infinity : Number(a.checkedAt);
      const bb = (b.checkedAt === null || b.checkedAt === undefined) ? Infinity : Number(b.checkedAt);
      if (aa !== bb) return aa - bb;

      // åŒã˜ checkedAt ã®å ´åˆã¯ createdAt ã§å®‰å®šåŒ–ï¼ˆä»»æ„ï¼‰
      const ac = Number(a.createdAt || 0);
      const bc = Number(b.createdAt || 0);
      return ac - bc;
    });

  renderHistoryList(ep);
}

async function openEndHistorySheet(){
  historyOverlay.classList.remove("hidden");
  historySheet.classList.remove("hidden");
  requestAnimationFrame(() => historySheet.classList.add("is-open"));

  // å¯¾å±€çµ‚äº†ç”»é¢ã¯ã€Œå…¨å±¥æ­´ã€ã‚’ checkedAt æ˜‡é †ã§è¡¨ç¤º
  historyCache = [];
  await loadHistoryAllOnceSortedByCheckedAtAsc();

  // å¯¾å±€çµ‚äº†å¾Œã«å±¥æ­´ãŒå¢—ãˆã‚‹ã‚±ãƒ¼ã‚¹ã‚‚æ‹¾ã„ãŸã„ãªã‚‰è³¼èª­ã‚‚å¯èƒ½ï¼ˆä»»æ„ï¼‰
  // subscribeHistoryAllByCheckedAtAsc();
}

// ä»»æ„ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§è¿½åŠ åˆ†ã‚‚åæ˜ ã—ãŸã„å ´åˆ
function subscribeHistoryAllByCheckedAtAsc(){
  if (!currentRoomId) return;
  if (historyUnsub) historyUnsub();

  const ref = db.ref(`rooms/${currentRoomId}/transferRequests`);

  const handler = async (snap) => {
    const obj = snap.val();
    if (!obj) return;

    const id = snap.key;
    if (historyCache.some(x => x._id === id)) return;

    historyCache.push({ _id: id, ...obj });
    historyCache.sort((a,b) => {
      const aa = (a.checkedAt === null || a.checkedAt === undefined) ? Infinity : Number(a.checkedAt);
      const bb = (b.checkedAt === null || b.checkedAt === undefined) ? Infinity : Number(b.checkedAt);
      if (aa !== bb) return aa - bb;
      const ac = Number(a.createdAt || 0);
      const bc = Number(b.createdAt || 0);
      return ac - bc;
    });

    const eSnap = await db.ref(`systemConfig/entryPlayers`).once("value");
    const ep = eSnap.val() || {};
    renderHistoryList(ep);
  };

  ref.on("child_added", handler);
  historyUnsub = () => ref.off("child_added", handler);
}


// è³¼èª­é–¢æ•°
function subscribeTransferRequests(){
  if (!currentRoomId) return;
  if (transferUnsub) transferUnsub();

  const roomId = currentRoomId;
  const myPid = currentGameInfo.playerId;
  if (!myPid) return;

  const ref = db.ref(`rooms/${roomId}/transferRequests`);

  const handler = async (snap) => {
    const req = snap.val();
    if (!req) return;

    // payment ã ã‘å—å–å´ã«ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ï¼ˆpendingã®ã¿ï¼‰
    if (req.type === "payment" && req.status === "pending" && req.toPlayerId === myPid) {
      // åå‰è¡¨ç¤ºç”¨
      const eSnap = await db.ref(`systemConfig/entryPlayers`).once("value");
      const ep = eSnap.val() || {};
      const fromName = ep[req.fromPlayerId]?.name ?? req.fromPlayerId;
      const toName   = ep[req.toPlayerId]?.name ?? req.toPlayerId;

      currentReceiveReqId = snap.key;

      setText("recvFromName", fromName);
      setText("recvToName", toName);
      setText("recvPoint", String(req.point ?? "-"));
      setText("recvToBefore", String(req.toBefore ?? "-"));
      setText("recvToAfter", String(req.toAfter ?? "-"));

      openReceiveSheet();
    }
  };

  // child_added ã ã¨å¤ã„å±¥æ­´ã‚‚å…¨éƒ¨æ¥ã‚‹ â†’ ã€Œæœªãƒã‚§ãƒƒã‚¯ã®ã‚‚ã®ã ã‘æ‹¾ã†ã€ã®ã§OK
  ref.on("child_added", handler);
  transferUnsub = () => ref.off("child_added", handler);
}


// ===============================
// å¯¾å±€çµ‚äº†ãƒœã‚¿ãƒ³
// ===============================
async function endGame() {
  try {
    if (!currentRoomId) return;
    if (isSpectatorMode) return;

    const myPid = myPlayerId || currentGameInfo.playerId;
    if (!myPid) return;

    const myStatusRef = db.ref(`rooms/${currentRoomId}/players/${myPid}/status`);

    // 1) ç¾åœ¨ã®è‡ªåˆ†statusã‚’ç¢ºèªï¼ˆplaying ã®ã¨ãã ã‘ calculating ã«ã™ã‚‹ï¼‰
    const stSnap = await myStatusRef.once("value");
    const cur = stSnap.val();

    if (cur !== "playing") {
      console.log("[endGame] skipped: status is not playing", { cur });
      alert("å¯¾å±€çµ‚äº†ã—ã¦ã„ã¾ã™ã€‚");
      return;
    }

    // 1.5) å…¨å“¡ãŒ returnPoint ä»¥ä¸Šã‹ãƒã‚§ãƒƒã‚¯
    const [playersSnap, configSnap] = await Promise.all([
      db.ref(`rooms/${currentRoomId}/players`).once("value"),
      db.ref(`rooms/${currentRoomId}/gameConfig`).once("value"),
    ]);

    const players = playersSnap.val() || {};
    const gameConfig = configSnap.val() || {};

    const returnPoint = Number(gameConfig.returnPoint || 0);

    // å‚åŠ è€…ã®ã¿ï¼šå…¨å“¡ãŒ returnPoint æœªæº€ã‹ï¼Ÿ
    const notReached = Object.values(players)
      .filter(p => p?.direction) // å‚åŠ è€…ã®ã¿
      .every(p => Number(p.point || 0) < returnPoint);

    if (notReached) {
      alert(`èª°ã‚‚${returnPoint}ç‚¹ã«é”ã—ã¦ã„ãªã„ãŸã‚çµ‚äº†ã§ãã¾ã›ã‚“`);
      return;
    }

    if(!confirm("å¯¾å±€ã‚’çµ‚äº†ã—ã¾ã™ã‹ï¼Ÿ")) return;

    // 2) calculating ã¸æ›´æ–°ï¼ˆset ã‚’ä½¿ç”¨ï¼‰
    await myStatusRef.set("calculating");

    const need = (gameConfig.rule === "3") ? 3 : 4;

    // å‚åŠ è€…ã®ã¿ï¼ˆdirectionãŒã‚ã‚‹äººï¼‰ã‚’å¯¾è±¡ã« counting
    const calcCount = Object.values(players)
      .filter(p => p?.direction)
      .filter(p => p?.status === "calculating")
      .length + 1; // â† ä»Šå›è‡ªåˆ†ãŒ calculating ã«ãªã£ãŸåˆ†ã‚’åŠ ç®—

    // 3) æœ€å¾Œã®äººãŒæŠ¼ã—ãŸã‚‰ roomStatus ã‚’ calculating ã«ï¼ˆset ã‚’ä½¿ç”¨ï¼‰
    if (calcCount >= need) {
      await db.ref(`rooms/${currentRoomId}/gameConfig/status`).set("calculating");
      // subscribeRoomStatus() ãŒå…¨å“¡ã‚’é›†è¨ˆä¸­ç”»é¢ã¸é·ç§»ã•ã›ã‚‹æƒ³å®š
    }

  } catch (e) {
    console.error("endGame error:", e);
    alert("å¯¾å±€çµ‚äº†ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n" + (e?.message ?? e));
  }
}

// ================================================
// GASé€£æºã€€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã¸ãƒ‡ãƒ¼ã‚¿æ›¸ãè¾¼ã¿
// ================================================
const GAS_URL = "https://script.google.com/macros/s/AKfycbyqghF0B_hau72utvGgNXu7k_n9lr0TJJEYFezIukl5wgkbEtgt0O8KRnGJqZZ_9b1MVw/exec";
const GAS_TOKEN = "a809ef3d-639b-449c-847b-326d59743eca"

async function requestGASApp(request) {

  // â˜…ã“ã‚Œã§CORSã‚¨ãƒ©ãƒ¼ã¯å‡ºã¾ã›ã‚“ï¼ˆãŸã ã—ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã¯èª­ã‚ãªã„ï¼‰
  fetch(GAS_URL, {
    method: "POST",
    mode: "no-cors",
    body: JSON.stringify({ "token": GAS_TOKEN, "request": request }),
  }).catch(console.error);
}

function openCalculatingScreen() {
  // ç”»é¢åˆ‡æ›¿
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  gameScreen?.classList.add("hidden");
  calculatingScreen.classList.remove("hidden");

  subscribeCalculating();
}

function subscribeCalculating() {
  if (!currentRoomId) return;

  if (calcUnsub) calcUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);
    renderCalculatingUI(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
    checkAllEndAndClose(pSnap.val() || {}, cSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  calcUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
}


function resolvePosPids(players) {
  const myPid = currentGameInfo.playerId;
  const myDir = currentGameInfo.direction;
  const out = { ME: myPid, N: null, W: null, S: null };

  for (const [pid, p] of Object.entries(players)) {
    if (!p?.direction) continue;
    if (pid === myPid) continue;

    const rel = toRelative(myDir, p.direction); // 'N'|'W'|'S' ã‚’è¿”ã™ã‚„ã¤
    if (rel) out[rel] = pid;
  }
  return out;
}


function calcScoreUnits(point, returnPoint) {
  return Math.ceil((Number(point || 0) - Number(returnPoint || 0)) / 1000);
}


function renderCalculatingUI(players, gameConfig, entryPlayers) {
  const pos = resolvePosPids(players);
  const returnPoint = Number(gameConfig.returnPoint || 0);

  // 4äººåˆ†ï¼ˆME/N/W/Sï¼‰ã‚’é…åˆ—åŒ–ï¼ˆå­˜åœ¨ã—ãªã„å¸­ã¯é™¤å¤–ï¼‰
  const list = ["ME","N","W","S"]
    .map(k => ({ k, pid: pos[k], p: pos[k] ? players[pos[k]] : null }))
    .filter(x => x.pid && x.p);

  // åå‰è¡¨ç¤ºï¼ˆæ–¹è§’ + nameï¼‰
  const nameOf = (pid) => entryPlayers[pid]?.name ?? "ä¸æ˜";
  const dirOf  = (pid) => players[pid]?.direction ?? "-";

  // è¡¨ç¤ºï¼š005/006/007/008
  // â˜…ç¸¦ä¸¦ã³ï¼ˆinnerHTMLï¼‰
  if (pos.N)  document.getElementById("calcTopName").innerHTML   = `<div>${dirOf(pos.N)}å®¶</div><div>${nameOf(pos.N)}</div>`;
  if (pos.W)  document.getElementById("calcLeftName").innerHTML  = `<div>${dirOf(pos.W)}å®¶</div><div>${nameOf(pos.W)}</div>`;
  if (pos.S)  document.getElementById("calcRightName").innerHTML = `<div>${dirOf(pos.S)}å®¶</div><div>${nameOf(pos.S)}</div>`;
  if (pos.ME) document.getElementById("calcMyName").innerHTML    = `<div>${dirOf(pos.ME)}å®¶</div><div>${nameOf(pos.ME)}</div>`;;

  // ã¾ãšâ‘¡ã®è¨ˆç®—ï¼ˆå…¨å“¡åˆ†ï¼‰
  const base = {};
  for (const x of list) {
    const u = calcScoreUnits(x.p.point, returnPoint);
    base[x.k] = u + (x.p.yakitoriFlg === true ? -10 : 0);
  }

  // ãƒˆãƒƒãƒ—åˆ¤å®šã¯ point ã®æœ€å¤§
  let topK = null;
  let topPoint = -Infinity;
  for (const x of list) {
    const pt = Number(x.p.point || 0);
    if (pt > topPoint) { topPoint = pt; topK = x.k; }
  }

  // â‘ ãƒˆãƒƒãƒ—ã¯ã€Œä»–äººåˆè¨ˆÃ—-1ã€
  if (topK) {
    const othersSum = Object.entries(base)
      .filter(([k]) => k !== topK)
      .reduce((acc, [,v]) => acc + Number(v||0), 0);

    base[topK] = -1 * othersSum;
  }

  // è¡¨ç¤ºï¼š009/010/011/012
  setText("calcTopScore",  pos.N  ? String(base["N"] ?? "-")  : "-");  // 010
  setText("calcLeftScore", pos.W  ? String(base["W"] ?? "-")  : "-");  // 009
  setText("calcRightScore",pos.S  ? String(base["S"] ?? "-")  : "-");  // 011
  setText("calcMyScore",   pos.ME ? String(base["ME"] ?? "-") : "-");  // 012

  // 001-004 ãƒ¤ã‚­ãƒˆãƒªãƒœã‚¿ãƒ³è¡¨ç¤ºï¼ˆtrueãªã‚‰ã€Œãƒ¤ã‚­ãƒˆãƒªã€ã€falseãªã‚‰ç©ºè¡¨ç¤ºï¼‰
  setYakitoriButton("btnYakitoriTop",   pos.N,  players);
  setYakitoriButton("btnYakitoriLeft",  pos.W,  players);
  setYakitoriButton("btnYakitoriRight", pos.S,  players);
  setYakitoriButton("btnYakitoriMe",    pos.ME, players);

  // rooms/{roomId}/gameConfig/status == end ã®å ´åˆãƒœã‚¿ãƒ³éæ´»æ€§
  const isRoomEnd = (gameConfig.status === "end");

  // player/{id}/status == "end" ã®äººã¯ãƒ¤ã‚­ãƒˆãƒªæ“ä½œä¸å¯ï¼ˆå€‹åˆ¥åˆ¤å®šï¼‰
  const isPlayerEnd = (pid) => !!pid && players?.[pid]?.status === "end";

  // é›†è¨ˆä¸­ç”»é¢ã§ã¯ã€Œè‡ªåˆ†(ME)ä»¥å¤–ã®ãƒ¤ã‚­ãƒˆãƒªãƒœã‚¿ãƒ³ã¯æ“ä½œä¸å¯ã€
  const myPid = pos.ME;

  const yakitoriMap = [
    ["btnYakitoriTop",   pos.N],
    ["btnYakitoriLeft",  pos.W],
    ["btnYakitoriRight", pos.S],
    ["btnYakitoriMe",    pos.ME],
  ];

  for (const [btnId, pid] of yakitoriMap) {
    const b = document.getElementById(btnId);
    if (!b) continue;

    const isOther = !!pid && pid !== myPid; // è‡ªåˆ†ä»¥å¤–
    b.disabled = isRoomEnd || isPlayerEnd(pid) || isOther;
  }

  // é›†è¨ˆå®Œäº†ãƒœã‚¿ãƒ³ã¯éƒ¨å±‹endã§ç„¡åŠ¹åŒ–
  const endBtn = document.getElementById("btnCalcEnd");
  if (endBtn) endBtn.disabled = isRoomEnd;

}

function computeScoresForRoom(players, gameConfig) {
  const returnPoint = Number(gameConfig.returnPoint || 0);

  // å‚åŠ è€…ã ã‘æŠ½å‡ºï¼ˆdirectionãŒã‚ã‚‹äººï¼‰
  const active = Object.entries(players || {})
    .filter(([pid, p]) => p?.direction) // å‚åŠ è€…ã®ã¿
    .map(([pid, p]) => ({ pid, p }));

  if (active.length === 0) return {};

  // â‘¡ï¼šceil((point-returnPoint)/1000) + (yakitoriFlg===true ? -10 : 0)
  const base = {};
  for (const { pid, p } of active) {
    const u = Math.ceil((Number(p.point || 0) - returnPoint) / 1000);
    base[pid] = u + (p.yakitoriFlg === true ? -10 : 0);
  }

  // â‘ ï¼špointæœ€å¤§ã®äººã‚’ãƒˆãƒƒãƒ—ã¨ã—ã€ä»–äººã®åˆè¨ˆÃ—-1
  let topPid = active[0].pid;
  let topPoint = Number(active[0].p.point || 0);
  for (const { pid, p } of active) {
    const pt = Number(p.point || 0);
    if (pt > topPoint) { topPoint = pt; topPid = pid; }
  }

  const othersSum = Object.entries(base)
    .filter(([pid]) => pid !== topPid)
    .reduce((acc, [,v]) => acc + Number(v || 0), 0);

  base[topPid] = -1 * othersSum;

  return base; // { pid: score, ... }
}

function setYakitoriButton(btnId, pid, players) {
  const btn = document.getElementById(btnId);
  if (!btn) return;

  const img = btn.querySelector(".yakitoriBtnImg");

  // pidãªã—/ãƒ‡ãƒ¼ã‚¿ãªã—ãªã‚‰ç„¡åŠ¹åŒ–ï¼†éè¡¨ç¤º
  if (!pid || !players[pid]) {
    btn.disabled = true;
    if (img) img.style.visibility = "hidden";
    return;
  }

  btn.disabled = false;
  if (img) img.style.visibility = "visible";

  const flg = players[pid].yakitoriFlg === true;
  const src = flg ? "image/yakitori_on.png" : "image/yakitori_off.png";

  if (img && !img.src.endsWith(src)) img.src = src;
}



async function toggleYakitoriByPos(which) {
  const pSnap = await db.ref(`rooms/${currentRoomId}/players`).once("value");
  const players = pSnap.val() || {};
  const pos = resolvePosPids(players);

  const pid = (which === "ME") ? pos.ME : pos[which];
  if (!pid) return;

  // ã©ã®ãƒœã‚¿ãƒ³ã‚’flipã•ã›ã‚‹ã‹
  const btnId =
    which === "N"  ? "btnYakitoriTop" :
    which === "W"  ? "btnYakitoriLeft" :
    which === "S"  ? "btnYakitoriRight" :
    /* ME */         "btnYakitoriMe";

  const cur = players[pid]?.yakitoriFlg === true;
  const next = !cur;

  // å…ˆã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆä½“æ„Ÿã‚’è‰¯ãã™ã‚‹ï¼‰
  flipYakitoriBtn(btnId, next);

  // DBæ›´æ–°ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è³¼èª­ã§æœ€çµ‚çš„ã«æ­£ã—ã„çŠ¶æ…‹ã«åæŸï¼‰
  const ref = db.ref(`rooms/${currentRoomId}/players/${pid}/yakitoriFlg`);
  await ref.set(next);
}


async function finishCalculating() {
  const pid = currentGameInfo.playerId;
  if (!pid) return;
  await db.ref(`rooms/${currentRoomId}/players/${pid}/status`).set("end");
  alert("é›†è¨ˆå®Œäº†ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚");
}


async function checkAllEndAndClose(players, gameConfig) {
  if (!currentRoomId) return;

  // ã™ã§ã«çµ‚äº†ç¢ºå®šæ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„ï¼ˆå¤šé‡å®Ÿè¡Œé˜²æ­¢ï¼‰
  if (gameConfig.status === "end") return;

  const endCount = Object.values(players || {}).filter(p => p?.status === "end").length;
  const need = (currentRule === "3") ? 3 : 4;
  if (endCount < need) return;

  // â˜…æœ€å¾Œã®äººãŒè¤‡æ•°åŒæ™‚ã«å…¥ã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ status ã‚’å…ˆã«ç¢ºèªã—ã¦ã‚¬ãƒ¼ãƒ‰
  const statusRef = db.ref(`rooms/${currentRoomId}/gameConfig/status`);
  const stSnap = await statusRef.once("value");
  const st = stSnap.val();
  if (st === "end") return;

  // scoreè¨ˆç®—ï¼ˆè¡¨ç¤ºã¨åŒã˜ï¼‰
  const scores = computeScoresForRoom(players, gameConfig);

  // players/{pid}/score ã«ä¸€æ‹¬åæ˜ ï¼ˆmulti-location updateï¼‰
  const updates = {};
  for (const [pid, sc] of Object.entries(scores)) {
    updates[`rooms/${currentRoomId}/players/${pid}/score`] = sc;
  }

  // ã¤ã„ã§ã« status ã‚’ end ã«ã™ã‚‹ï¼ˆé›†è¨ˆå®Œäº†ã®ç¢ºå®šï¼‰
  updates[`rooms/${currentRoomId}/gameConfig/status`] = "end";

  await db.ref().update(updates);

  // GASé€£æºå‡¦ç†ã€€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã¸æ›¸ãè¾¼ã¿ä¾é ¼
  // --- createdAt â†’ "YYYY-MM-DD"ï¼ˆJSTåŸºæº–ï¼‰
  const createdAt = gameConfig?.createdAt;
  const date = createdAt
    ? (() => {
        const d = new Date(createdAt);
        // ä¾‹: "2026/02/04" â†’ "2026-02-04"
        return new Intl.DateTimeFormat("ja-JP", {
          timeZone: "Asia/Tokyo",
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
        }).format(d).replaceAll("/", "-");
      })()
    : "";

  // --- systemConfig/entryPlayers ã¨çªåˆã—ã¦ dataList ã‚’ä½œæˆ
  const entrySnap = await db.ref(`systemConfig/entryPlayers`).once("value");
  const entryPlayers = entrySnap.val() || {};

  // directionã¯è€ƒæ…®ã—ãªã„ï¼šplayers ã¨ entryPlayers ã® playerId ãŒä¸€è‡´ã™ã‚‹ã‚‚ã®ã ã‘
  const dataList = Object.entries(players)
    .filter(([pid]) => entryPlayers?.[pid])   // entryPlayersã«å­˜åœ¨ã™ã‚‹IDã®ã¿
    .map(([pid, p]) => ({
      name: entryPlayers[pid]?.name ?? "",
      score: Number(p?.score ?? 0),
    }));

  // --- ãƒ‡ãƒ¼ã‚¿æ•´å½¢ï¼ˆä¾‹ã®JSONå½¢å¼ï¼‰
  const payload = { "date": date, "dataList": dataList };

  // å¿…è¦ãªã‚‰DBã¸ä¿æŒï¼ˆå¾Œç¶šå‡¦ç†ã§GASã¸é€ã‚‹ç­‰ã«ä½¿ãˆã‚‹ï¼‰
  await db.ref(`rooms/${currentRoomId}/gameConfig/resultPayload`).set(payload);

  requestGASApp(payload);

  alert("å…¨å“¡ã®é›†è¨ˆå®Œäº†ãŒæƒã„ã¾ã—ãŸã€‚ã‚¹ã‚³ã‚¢ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼ˆå¯¾å±€çµ‚äº†ç”»é¢ã¯æœªä½œæˆï¼‰");
  openEndScreen();
}



// ===============================
// å¯¾å±€çµ‚äº†ç”»é¢ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è³¼èª­
// ===============================
function openEndScreen() {
  // ç”»é¢åˆ‡æ›¿
  loginScreen?.classList.add("hidden");
  roomListScreen?.classList.add("hidden");
  addPlayerScreen?.classList.add("hidden");
  gameScreen?.classList.add("hidden");
  calculatingScreen?.classList.add("hidden");
  endScreen.classList.remove("hidden");

  subscribeEndScreen();
}

function subscribeEndScreen() {
  if (!currentRoomId) return;

  if (endUnsub) endUnsub();

  const playersRef = db.ref(`rooms/${currentRoomId}/players`);
  const configRef  = db.ref(`rooms/${currentRoomId}/gameConfig`);
  const entryRef   = db.ref(`systemConfig/entryPlayers`);

  const handler = async () => {
    const [pSnap, cSnap, eSnap] = await Promise.all([
      playersRef.once("value"),
      configRef.once("value"),
      entryRef.once("value"),
    ]);

    renderEndScreen(pSnap.val() || {}, cSnap.val() || {}, eSnap.val() || {});
  };

  playersRef.on("value", handler);
  configRef.on("value", handler);

  endUnsub = () => {
    playersRef.off("value", handler);
    configRef.off("value", handler);
  };

  handler();
}

function renderEndScreen(players, gameConfig, entryPlayers) {
  // 001 ãƒ«ãƒ¼ãƒ«è¡¨ç¤º
  const ruleMap = { "3":"3éº»", "3r4":"3éº»4äººå›", "4":"4éº»" };
  const ruleText = ruleMap[gameConfig.rule] || gameConfig.rule || "-";
  const ruleBtn = document.getElementById("endRuleBtn");
  if (ruleBtn) ruleBtn.textContent = ruleText;

  // 002,003 åŸç‚¹/è¿”ã—ç‚¹
  setText("endStartPoint", gameConfig.startPoint ?? "-");
  setText("endReturnPoint", gameConfig.returnPoint ?? "-");

  // å‚åŠ è€…ï¼ˆdirectionãŒã‚ã‚‹äººï¼‰ã ã‘ã‚’å¯¾è±¡ã«ã€scoreé™é †ã§ä¸¦ã¹ã‚‹
  const list = Object.entries(players || {})
    .filter(([pid, p]) => p?.direction) // å‚åŠ è€…
    .map(([pid, p]) => ({
      pid,
      name: entryPlayers?.[pid]?.name ?? "ä¸æ˜",
      score: (p.score ?? null),
      yakitori: (p.yakitoriFlg === true),
      point: Number(p.point ?? 0),
    }))
    // scoreãŒæœªè¨ˆç®—ï¼ˆnullï¼‰ã®äººã¯æœ€å¾Œã«å›ã™
    .sort((a, b) => {
      const as = (a.score === null || a.score === undefined) ? -Infinity : Number(a.score);
      const bs = (b.score === null || b.score === undefined) ? -Infinity : Number(b.score);
      if (bs !== as) return bs - as;
      // åŒç‚¹ãªã‚‰ point ã§å®‰å®šåŒ–ï¼ˆä»»æ„ï¼‰
      return (b.point - a.point);
    });

  // 3éº»ãªã‚‰4ä½æ ã‚’éš ã™ï¼ˆè¦‹ãŸç›®ã®è¦æœ›ãŒã‚ã‚‹å ´åˆï¼‰
  const is3 = (gameConfig.rule === "3");
  const rank4Box = document.getElementById("rank4Box");
  if (rank4Box) rank4Box.style.display = is3 ? "none" : "block";

  // 004-011, 012-015 åŸ‹ã‚ã‚‹
  const ranks = [
    { nameId:"rank1Name", scoreId:"rank1Score", yId:"rank1Yakitori" },
    { nameId:"rank2Name", scoreId:"rank2Score", yId:"rank2Yakitori" },
    { nameId:"rank3Name", scoreId:"rank3Score", yId:"rank3Yakitori" },
    { nameId:"rank4Name", scoreId:"rank4Score", yId:"rank4Yakitori" },
  ];

  const showCount = is3 ? 3 : 4;

  for (let i = 0; i < ranks.length; i++) {
    const r = ranks[i];
    const row = list[i];

    if (i >= showCount) {
      // 3éº»ã®4ä½ã¯éè¡¨ç¤ºæƒ³å®šã ãŒã€å¿µã®ãŸã‚ã‚¯ãƒªã‚¢
      setText(r.nameId, "-");
      setText(r.scoreId, "-");
      setText(r.yId, "");
      continue;
    }

    if (!row) {
      setText(r.nameId, "-");
      setText(r.scoreId, "-");
      setText(r.yId, "");
      continue;
    }

    setText(r.nameId, row.name);                 // 004-007
    setText(r.scoreId, row.score ?? "-");        // 008-011
    setText(r.yId, row.yakitori ? "ãƒ¤ã‚­ãƒˆãƒª" : ""); // 012-015
  }
}

// ç”»é¢é›¢è„±æ™‚ã¯è³¼èª­è§£é™¤
function stopAllSubscriptions() {
  const safelyOff = (fnName) => {
    try {
      const fn = window[fnName];
      if (typeof fn === "function") fn();
    } catch {}
  };

  // å¤‰æ•°å‹unsubscribeã®å…¸å‹ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ï¼‰
  if (roomsUnsub) { roomsUnsub(); roomsUnsub = null; }
  if (entryPlayersUnsub) { entryPlayersUnsub(); entryPlayersUnsub = null; }
  if (gameStateUnsub) { gameStateUnsub(); gameStateUnsub = null; }
  if (transferUnsub) { transferUnsub(); transferUnsub = null; }
  if (historyUnsub) { historyUnsub(); historyUnsub = null; }
  if (calcUnsub) { calcUnsub(); calcUnsub = null; }
  if (endUnsub) { endUnsub(); endUnsub = null; }
  if (statusUnsub) { statusUnsub(); statusUnsub = null; }
  if (gyakuUnsub) { gyakuUnsub(); gyakuUnsub = null; }
}



// ------------------- DBå‰Šé™¤ -------------------
function deleteRoom(roomId) {
  if(!confirm("ã“ã®ãƒ«ãƒ¼ãƒ ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ")) return;
  // ç‰©ç†å‰Šé™¤
  db.ref(`rooms/${roomId}`).remove();
  // è«–ç†å‰Šé™¤
  // db.ref(`rooms/${roomId}/gameConfig/status`).set("delete");
  db.ref(`rooms/${roomId}`).remove();
}



// ================= æˆ»ã‚‹ =================
function backToPlayerSetup() {
  addPlayerScreen.classList.add("hidden");

  if (addPlayerReturnTo === "playerConfig") {
    openPlayerConfigScreen("");
    return;
  }
  // ãã‚Œä»¥å¤–ã¯ãƒ«ãƒ¼ãƒ ä¸€è¦§ã¸
  showRoomListScreen();
}


// ãƒ«ãƒ¼ãƒ ä¸€è¦§ç”»é¢ã¸ã®é·ç§»
function backToRoomList() {
  try {
    // å…ˆã«è³¼èª­è§£é™¤ï¼ˆç”»é¢åˆ‡æ›¿å‰ã«å®‰å…¨ã«ï¼‰
    if (calcUnsub) { calcUnsub(); calcUnsub = null; }
    if (statusUnsub) { statusUnsub(); statusUnsub = null; }
    if (gameStateUnsub) { gameStateUnsub(); gameStateUnsub = null; }
    if (endUnsub) { endUnsub(); endUnsub = null; }
    if (roomsUnsub) { roomsUnsub(); roomsUnsub = null; }
    if (entryPlayersUnsub) { entryPlayersUnsub(); entryPlayersUnsub = null; } // â˜…è¿½åŠ ï¼ˆä»»æ„ï¼‰

    hideAllScreens();

    // â˜…ä¿å­˜ã™ã‚‹screenåã¯å®Ÿåœ¨ã™ã‚‹IDã«åˆã‚ã›ã‚‹
    saveAppState("roomListScreen");

    roomListScreen.classList.remove("hidden");

    // ä¸€è¦§æç”»
    subscribeEntryPlayers();
    subscribeRooms();
  } catch (e) {
    console.error("backToRoomList error:", e);

    // â˜…æœ€æ‚ªã§ã‚‚ roomList ã¯å‡ºã™ï¼ˆçœŸã£ç™½å›é¿ï¼‰
    hideAllScreens();
    roomListScreen.classList.remove("hidden");
    alert("ç”»é¢é·ç§»ã§ã‚¨ãƒ©ãƒ¼ã€‚ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã® backToRoomList error ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
  }
}


// ç”»é¢ç¸¦æ¨ªèª¿æ•´ç”¨
function applyOrientationClass(){
  const isLandscape = window.matchMedia("(orientation: landscape)").matches;
  document.documentElement.classList.toggle("is-landscape", isLandscape);
  document.documentElement.classList.toggle("is-portrait", !isLandscape);
}

window.addEventListener("load", applyOrientationClass);
window.addEventListener("resize", applyOrientationClass);
window.addEventListener("orientationchange", applyOrientationClass);


// sessionStorageã«å¿…è¦ãªæƒ…å ±æ ¼ç´
function saveAppState(screen) {
  sessionStorage.setItem(APP_STATE_KEY, JSON.stringify({
    loggedIn: true,
    screen,
    roomId: currentRoomId ?? null,
    currentGameInfo: currentGameInfo ?? {},
    myDeviceId: myDeviceId ?? null,
    myPlayerId: myPlayerId ?? null
  }));
}

window.addEventListener("load", async () => {

  // Service Worker ç™»éŒ²ï¼ˆãã®ã¾ã¾ï¼‰
  if ("serviceWorker" in navigator) {
    try {
      await navigator.serviceWorker.register("/sw.js");
      console.log("SW registered");
    } catch (e) {
      console.log("SW register failed:", e);
    }
  }

  const stateStr = sessionStorage.getItem(APP_STATE_KEY);
  if (!stateStr) return;

  let state;
  try { state = JSON.parse(stateStr); }
  catch {
    sessionStorage.removeItem(APP_STATE_KEY);
    return;
  }

  if (!state.loggedIn) return;

  // â˜…ãƒ­ã‚°ã‚¤ãƒ³æ¸ˆã¿ãªã‚‰ã€deviceMapåˆ¤å®šã¸
  await bootstrapAfterLogin();
});

let vhT1 = null;
let vhT2 = null;
let vhT3 = null;

function isPortraitNow() {
  // orientationchangeç›´å¾Œã¯ innerWidth/innerHeight ãŒå˜˜ã‚’ã¤ãã“ã¨ãŒã‚ã‚‹ã®ã§ã€
  // visualViewport ãŒã‚ã‚Œã°ãã£ã¡å„ªå…ˆ
  const vv = window.visualViewport;
  if (vv) return vv.height >= vv.width;
  return window.matchMedia("(orientation: portrait)").matches;
}

function setRealVH(){
  const vv = window.visualViewport;
  const baseH = (vv?.height ?? window.innerHeight);

  const isPortrait = vv ? (vv.height >= vv.width) : (window.innerHeight >= window.innerWidth);

  const adjustedH = baseH - (isPortrait ? 100 : 30);
  document.documentElement.style.setProperty("--vh", `${adjustedH * 0.01}px`);
}

// ç«¯æœ«ãŒå›è»¢ã—ãŸç›´å¾Œã¯å€¤ãŒæºã‚Œã‚‹ã“ã¨ãŒã‚ã‚‹ã®ã§ã€
// 1å› + æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ  + å°‘ã—å¾Œ(ä¿é™º) ã§å†è¨ˆç®—
function refreshVH(){
  setRealVH();
  requestAnimationFrame(setRealVH);
  setTimeout(setRealVH, 200);
}

// åˆæœŸåŒ–
refreshVH();

// æ—¢å­˜ï¼šãƒªã‚µã‚¤ã‚º
window.addEventListener("resize", refreshVH);
window.visualViewport?.addEventListener("resize", refreshVH);

// â˜…è¿½åŠ ï¼šç¸¦æ¨ªåˆ‡æ›¿ã®ãŸã³ã«å®Ÿè¡Œï¼ˆã“ã‚ŒãŒç›®çš„ï¼‰
window.addEventListener("orientationchange", refreshVH);

// ï¼ˆä»»æ„ï¼šiOS Safariå¯¾ç­–ï¼‰ãƒšãƒ¼ã‚¸ãŒæˆ»ã£ã¦ããŸæ™‚ã«ã‚‚å†è¨ˆç®—
window.addEventListener("pageshow", refreshVH);


</script>
</body>
</html>
